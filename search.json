[{"title":"从0到1开发Hexo主题杂谈","url":"/2019/08/20/develop-hexo-theme-from-0-to-1/","content":"\n## 前言\n\n在没有开发自己的 Hexo 主题之前，我都是在 Github Issue 里写[博客](https://github.com/liuyib/blog/issues)，但这样的做法总被小伙伴各种吐槽 (￣_￣ )。想到如果文章多的时候，使用 Github Issue 浏览起来不够方便，所以还是换回了 Hexo。\n\n使用 Hexo 首先是要挑选喜欢的主题，以我个人的感受来讲，Hexo 的主题虽然有两百多个，但是能拿出手的也就不到二十个。其中我最佩服的主题 Next 已经足够优秀，但是风格我并不喜欢，最后决定自己开发。\n\n本文主要记录了我从零开发 Hexo 主题 -- [Stun](https://github.com/liuyib/hexo-theme-stun) 时，遇到的所有坑和经验，**仅供参考**，有不足的地方欢迎指出。\n\n<!-- more -->\n\n## 知识储备\n\n### 模板引擎\n\n传统的 HTML 写起来既不方便，又不能复用，因此在 Hexo 中通常使用模板引擎来呈现网站内容。\n\n常用的几种模板引擎有：[Swig](https://github.com/paularmstrong/swig)、[EJS](https://github.com/hexojs/hexo-renderer-ejs)、[Haml](https://github.com/hexojs/hexo-renderer-haml) 或 [Jade](https://github.com/hexojs/hexo-renderer-jade)。其中 Jade 由于商标问题，改名为 [Pug](https://github.com/pugjs/pug)，虽然它们是兼容的，但使用的时候，推荐安装 Pug 而不是 Jade。Hexo 内置了 Swig，将文件扩展名改为 `.swig` 即可使用，你也可以安装插件来获得另外几种模板引擎的支持，Hexo 会根据文件扩展名来决定使用哪一种。例如：\n\n``` text\nlayout.pug   -- 使用 pug\nlayout.swig  -- 使用 swig\n```\n\n这里你需要做的是，选择一个自己喜欢的模板引擎，然后浏览文档，了解这个模板引擎的基本用法。\n\n- 英文文档地址分别如下：[Swig](https://node-swig.github.io/swig-templates/docs/)、[EJS](https://ejs.co/#docs)、[Pug](https://pugjs.org/api/getting-started.html)、[Haml](http://haml.info/docs.html)。\n- 中文文档地址分别如下：[Swig](https://myvin.github.io/swig.zh-CN/docs/index.html)、[EJS](https://ejs.bootcss.com/#docs)、[Pug](https://pugjs.org/zh-cn/api/getting-started.html)、Haml（无）。\n\n这里我选择了 Pug，不过推荐使用 Swig 或 EJS。\n\n### CSS 预处理语言\n\n你可以使用原生 CSS 来写样式，但是原生 CSS 不能使用变量，不能复用，也没有函数，这会导致主题开发变得相对麻烦，甚至某些功能无法实现，因此最好是使用 CSS 预处理语言。\n\n常见的 CSS 预处理语言有：[Less](http://lesscss.org/)、[Sass](https://sass-lang.com/)、[Stylus](http://stylus-lang.com/)。至于它们的选择，根据自己的喜好即可。Hexo 默认使用的是 Stylus，它的功能足够强大，完全够用，因此我选用了 Stylus。\n\n### Hexo 相关知识\n\n有关 Hexo 的知识，这里只列举必要的部分。\n\n#### 构建 Hexo 开发环境\n\n开发主题之前，你需要搭建自己的 Hexo 工作目录，有两种方式可供选择：\n\n1. 使用 `hexo-cli`\n2. 克隆 Hexo 主题的单元测试项目\n\n第一种方式，去 Hexo [官网](https://hexo.io/zh-cn/)，按照提示安装 `hexo-cli` 并生成你的 Hexo 工作目录，目录主要部分如下：\n\n``` text\n.\n├── scaffolds\n├── source\n|   └── _posts\n├── themes\n├── .gitignore\n├── _config.yml\n└── package.json\n```\n\n第二种方式，克隆 Hexo 官方的[单元测试库](https://github.com/hexojs/hexo-theme-unit-test)，这样会得到同上的文件目录。然后执行指令 `npm install` 安装所有依赖。\n\n对于一般的 Hexo 用户，都是使用第一种方式。不过对于 Hexo 主题开发者来说，如果你的主题将来要发布到 Hexo 的[主题列表](https://hexo.io/themes)，建议直接在 Hexo 的主题单元测试项目中进行开发，也就是第二种方式。原因是因为 Hexo 建议在主题发布前，先进行主题单元测试，确保每一项功能都能正常使用。Hexo 提供的单元测试库包括了所有的边缘情况，直接在上面开发就可以在开发时注意到这些边缘情况，而不是开发完再去测试。\n\n搭建完 Hexo 开发环境后，需要安装相关插件来支持你所使用的渲染引擎。Hexo 默认安装的渲染引擎是 EJS 和 Stylus，并且 Hexo 内置了 Swig，因此，如果你选用了 `EJS + Stylus` 或 `Swig + Stylus`，那么可以忽略这段，如果你选择了其他的渲染引擎，需要自行选择安装：\n\n``` bash\n# Templates\n$ npm install --save hexo-renderer-ejs\n$ npm install --save hexo-render-pug\n$ npm install --save hexo-render-haml\n\n# Styles\n$ npm install --save hexo-renderer-less\n$ npm install --save hexo-renderer-sass\n$ npm install --save hexo-renderer-stylus\n```\n\n#### 生成主题结构目录\n\n上一步只是搭建好了 Hexo 工作目录，接下来是创建主题的文件目录，你可以参考着已有的主题的文件目录手动创建，也可以使用 `Yeoman` 自动生成，使用 `Yeoman` 自动生成的步骤如下。\n\n1. 安装\n\n``` bash\n$ npm install --global yo\n$ npm install --global generator-hexo-theme\n```\n\n2. 生成\n\n进入 Hexo 的 `themes` 目录中，新建一个文件夹作为你的主题目录，然后进入该文件夹中，执行指令：\n\n``` bash\nyo hexo-theme\n```\n\n按照提示，填写或选择相应的信息，如下图：\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-theme-stun/doc/20190822211939.png)\n\n生成的文件目录如下：\n\n``` text\n.\n├── layout        # 布局文件夹\n|   ├── includes\n|   |   ├── layout.pug       # 页面总体布局\n|   |   └── recent-posts.pug # 文章列表\n|   ├── index.pug            # 首页\n|   ├── archive.pug          # 归档页\n|   ├── category.pug         # 分类页\n|   ├── tag.pug              # 标签页\n|   ├── post.pug             # 文章页\n|   └── page.pug             # 除以上页面之外的页面\n├── scripts       # 脚本文件夹\n├── source        # 资源文件夹\n|   ├── css\n|   ├── js\n|   └── favicon.ico\n├── .editorconfig # 编辑器配置文件\n├── _config.yml   # 主题配置文件\n└── package.json\n```\n\n当然只有这些文件目录是不够的，我们还需要另外添加一些其他的文件或目录，例如，`languages` 目录，放置语言文件，用于[国际化（i18n）](https://hexo.io/zh-cn/docs/internationalization)设置（如果想要你的主题支持多语言，就需要添加该目录）。\n\n有关以上目录的介绍，详参见：[Hexo 主题](https://hexo.io/zh-cn/docs/themes)。\n\n这里需要提一下，主题目录和 Hexo 根目录中各有一个 `source` 文件夹，当你执行指令 `hexo generate` 来生成静态文件时，这两个 `source` 目录中的文件如果是 Markdown 会被解析为 HTML，其他不能解析的文件，会被复制到 `public` 目录中。`public` 目录用于存放生成的静态文件，这些静态文件就是线上跑的网站文件。因此，如果你不清楚 `source` 目录里文件的使用路径是怎样的，那么你可以跑一下指令 `hexo generate`，这些文件生成到 `public` 目录中后，它们的路径关系就很明显了。\n\n#### 通读文档\n\n虽然 Hexo 的文档确实很差劲，文档下面的评论区全是吐槽，而且有些部分中英文版本没有同步，但是如果能耐心读完，会有很大的收益，我个人的最大感受是 Hexo 的文档真的特别重要。当然一次掌握是不可能的，最好在开发时每隔一段时间过一遍。\n\n刚开始开发主题，不可能理解 Hexo 文档中提到的所有地方，但是有两个点必须首先掌握：[变量](https://hexo.io/zh-cn/docs/variables)和[辅助函数](https://hexo.io/zh-cn/docs/helpers)，这两点在开发时会经常用到，并且贯穿整个开发过程。\n\n## 主题开发\n\n有了上述的准备后，就可以开始主题的开发了。下面是主题开发中一些值得注意的地方，了解这些，可以帮助你避免踩重复的坑。\n\n### 主题配置文件\n\n主题的配置文件采用了 [Yaml](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html) 语法，和 Json 类似，了解一下语法格式就可以上手使用了。\n\n开发主题时，有的功能可以让用户自己配置，因此我们需要将这些功能的配置项暴露出来，填充到主题的配置文件 `_config.yml` 中。然后在模板引擎中，你可以通过 Hexo 内置的 `theme` 变量来获取这些配置项。例如：\n\n配置文件：\n\n``` yaml _config.yml\ncopyright:\n  enable: true\n  text:\n```\n\n这样使用：\n\n``` html\n// -------------------- Pug 语法 --------------------\nif theme.copyright.enable\n  div.copyright= theme.copyright.text\n\n// -------------------- Swig 语法 --------------------\n{% if theme.copyright.enable %}\n<div class=\"copyright\">{{ theme.copyright.text }}</div>\n{% endif %}\n```\n\n{% note default  %}\n后面的文章中，模板语言示例代码都会用 Pug 和 Swig 两种语法给出。\n{% endnote  %}\n\n随着项目的发展，配置文件会越来越大，上面这种做法的缺点也会越来越明显。\n\n- 对于使用者\n\n  当更新主题时，由于配置文件会被覆盖，因此用户必须提前将配置文件备份，等更新完主题后再将备份的数据拷贝回去，这个过程繁琐又容易出错。\n\n- 对于开发者\n\n  在发布主题时，开发者不可能将自己测试用的数据保留在主题配置文件中，而应该预留一份干净的配置文件。因此每次发布主题之前，都需要把主题配置文件里的测试数据清空、备份，然后等发布完主题后再恢复回来。这种做法是无法令人忍受的，因为每次 `git commit` 之前都需要这样做一次。\n\n因此我们需要一种更友好的方式来使用配置文件。在查找资料和参考现有主题 NexT、Melody 的实现后，发现可以利用 Hexo 3.0 提供的新特性 -- [数据文件](https://hexo.io/zh-cn/docs/data-files)，来解决上面的痛点。\n\n使用方法如下，在 Hexo 根目录下的 `source/_data` 文件夹中（没有的文件夹需要自己创建），新建一个 Yaml 配置文件，并**命名为主题的名称**，例如 Stun 主题，就叫做 `stun.yml`。然后将主题配置文件 `_config.yml` 里的内容复制到 `stun.yml` 中，这样 `stun.yml` 就会覆盖 `_config.yml`。如果想要修改配置，直接修改 `stun.yml` 就好了。当用户更新主题或者开发者发布主题时，配置数据保存在 `stun.yml` 中，主题原来的配置文件 `_config.yml` 仍然是干净的。\n\n下面是代码实现，在主题根目录下的 `scripts` 文件夹中（没有就新建），添加一个 JS 文件，文件名随意，添加如下代码：\n\n``` js\nhexo.on('generateBefore', function () {\n  var rootConfig = hexo.config;\n\n  if (hexo.locals.get) {\n    // 获取 source/_data 目录下的文件\n    var data = hexo.locals.get('data');\n\n    // 如果存在 stun.yml 文件，就用它覆盖原来的配置文件\n    if (data && data.stun) {\n      hexo.theme.config = data.stun;\n    }\n  }\n\n  hexo.theme.config.rootConfig = rootConfig;\n});\n```\n\n### 页面搭建\n\n你需要分析主题页面的结构，将能够公用的部分抽离出来，例如：\n\n- HTML 的 `head` 部分\n- 顶部导航栏\n- 页面头部、底部\n- 页面侧边栏\n- 页面主体部分（显示文章的地方）\n- ......\n\n将这些部分对应的代码放在主题 `layout` 目录下的 `layout.pug` 文件中用以复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n  body\n    header#header.header\n      div.header-inner\n        include ./header.pug\n    \n    main#main.main\n      div.main-inner\n        div#content.content\n          div.content-inner\n            block content\n        \n        div#sidebar.sidebar\n          div.sidebar-inner\n            block sidebar\n\n    footer#footer.footer\n      div.footer-inner\n        include ./footer.pug\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n\n  <body>\n    <header id=\"header\" class=\"header\">\n      <div class=\"header-inner\">\n        {% include './header.swig' %}\n      </div>\n    </header>\n\n    <main id=\"main\" class=\"main\">\n      <div class=\"main-inner\">\n        <div id=\"content\" class=\"content\">\n          <div class=\"content-inner\">\n            {% block content %}{% endblock %}\n          </div>\n        </div>\n        \n        <div id=\"sidebar\" class=\"sidebar\">\n          <div class=\"sidebar-inner\">\n            {% block sidebar %}{% endblock %}\n          </div>\n        </div>\n      </div>\n    </main>\n\n    <footer id=\"footer\" class=\"footer\">\n      <div class=\"footer-inner\">\n        {% include './footer.swig' %}\n      </div>\n    </footer>\n  </body>\n</html>\n```\n\n`layout.pug` 是网站最基础的布局代码，所有的页面都是继承它而来。Pug / Swig 使用 `extends` 和 `block` 实现继承，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n\n  body\n    block content\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n  <body>\n    {% block content %}{% endblock %}\n  </body>\n</html>\n```\n\n``` html\n// -------------------- Pug 语法 --------------------\nextends layout.pug\n\nblock title\n  My Page\n\nblock content\n  This is a awesome page.\n\n// -------------------- Swig 语法 --------------------\n{% extends 'layout.swig' %}\n\n{% block title %}My Page{% endblock %}\n\n{% block content %}\n<p>This is a awesome page.</p>\n{% endblock %}\n```\n\n除了继承的方式复用代码，还可以通过 `include` 语法直接引文件来实现代码复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\ndiv#header.header\n  include ./header.pug\n\n// -------------------- Swig 语法 --------------------\n<div id=\"header\" class=\"header\">\n  {% include './header.swig' %}\n</div>\n```\n\n> 由于 `layout.pug` 只用于被其他页面继承，并不会单独渲染成页面，因此，可以将文件名改为 `_layout.pug`（以下划线开头）这样 Hexo 就不会解析这个文件，可以提高 Hexo 生成页面的速度。\n\n这里我并不准备介绍页面中更详细的部分如何实现，直接看[源码](https://github.com/liuyib/hexo-theme-stun)效果更好。\n\n### 数据交互\n\n这里介绍下 Pug / Swig、Stylus、JavaScript 这几种文件如何与主题配置文件进行数据交互。\n\n前面我们已经知道了，主题配置文件里的配置项被包含在 `theme` 变量下。因此在我们需要知道如何在另外三种文件中使用 `theme` 变量：\n\n- 在 Pug / Swig 文件中使用\n\n  ``` html\n  // -------------------- Pug 语法 --------------------\n  div= theme.copyright.text\n\n  html(lang=theme.language)\n\n  if theme.sidebar.enable\n    div.sidebar\n\n  div(class=`sidebar ${ if theme.sidebar.show ? 'show' : '' }`)\n\n  // -------------------- Swig 语法 --------------------\n  <div>{{ theme.copyright.text }}</div>\n\n  <html lang=\"{{ theme.language }}\"></html>\n\n  {% if theme.sidebar.enable %}\n    <div class=\"sidebar\"></div>\n  {% endif %}\n\n  <div class=\"sidebar {% if theme.sidebar.show %}show{% endif %}\"></div>\n  ```\n\n- 在 Stylus 文件中使用\n\n  需要通过 Hexo 内置的函数 `hexo-config` 来获取 `theme` 变量中的属性，但是不需要写 `theme`：\n\n  ``` stylus\n  // back2top 是 theme 变量下的一个属性\n  if (hexo-config('back2top.enable'))\n    .back2top\n      display: block\n\n  // 如果配置项的值中含有样式，需要使用 Stylus 的 convert 函数转换一下\n  .post-title\n    color: convert(hexo-config('post.title.color'))\n  ```\n\n- 在 JavaScript 文件中使用\n\n  在 JS 文件中没有办法直接获取到 Hexo 内置的 `theme` 变量，但是我们可以换一种方式来间接获取。新建一个模板引擎文件，我们就叫它 `config.pug`，文件内容如下所示：\n\n  ``` html\n  // ----- Pug 语法（注意 script 标签后面的点，表示该标签后面有多行代码）-----\n  script.\n    var CONFIG = {\n      sidebar: '!{ theme.sidebar }',\n      back2top: '!{ theme.back2top }',\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n\n  // -------------------- Swig 语法 --------------------\n  <script>\n    var CONFIG = {\n      sidebar: {{ theme.sidebar | json_encode }},\n      back2top: {{ theme.back2top | json_encode }},\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n  </script>\n  ```\n\n  然后将 `config.pug` 文件放在 HTML 的 `head` 标签中加载，这样就可以通过全局变量 `CONFIG` 在 JS 中获取主题配置文件里的数据了。\n\n到这里为止，就介绍完了开发 Hexo 主题前必要的知识储备，剩下的就靠开发者自己完成了。\n\n## 发布主题\n\n发布主题之前你需要进行[主题单元测试](https://github.com/hexojs/hexo-theme-unit-test)，确保每一项功能都能正常使用。如果你是按照我之前介绍的方法，直接 Hexo 的主题单元测试库中开发主题，那么你应该就不需要进行这一步了。\n\n1、Fork [hexojs/site](https://github.com/hexojs/site)\n2、编辑 `source/_data/themes.yml`，在文件中新增您的主题：\n\n``` yaml themes.yml\n- name: Stun\n  description: A beautiful & simple theme\n  link: https://github.com/liuyib/hexo-theme-stun\n  preview: https://liuyib.github.io/\n  tags:\n    - responsive\n    - beautiful\n    - simple\n    - two_column\n```\n\n3、在 `source/themes/screenshots` 中添加一个和你主题同名的图片，图片必须为 800*500 的 PNG 文件。\n4、发起新的合并申请（pull request）。\n\n最后，只需要等待 Hexo 仓库的维护人员收录你的主题即可。\n\n---\n\n参考链接：\n\n- [Hexo主题开发经验杂谈](https://molunerfinn.com/make-a-hexo-theme/)\n- [Hexo 主题开发指南](http://chensd.com/2016-06/hexo-theme-guide.html)\n","tags":["hexo","hexo-theme"],"categories":["hexo-theme","hexo主题开发"]},{"title":"theme-stun-gitter","url":"/2019/07/26/theme-stun-gitter/","content":"\nThis is a link for Gitter of theme-stun. Clicking on the title to talking.\n"},{"title":"前端单元测试和持续集成","url":"/2019/06/04/front-end-unit-test-and-ci/","content":"\n经常使用 Github 的同学应该知道，一些开源项目中常常会挂上很多花花绿绿了的小徽章，比如 vue 的：\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131517.png)\n\n这些徽章不仅起到装饰 README 的作用，更给人以安全可靠的感觉。由于好奇，自己也探究了一番。\n\n## 给项目装上徽章\n\n想要获取徽章，有很多方式，最简单的可以通过 [shields.io](https://shields.io/) 网站获取，基本上想要的徽章都能获取到，没有的也可以进行 DIY，很方便。\n\n举个例子，将项目的开源协议通过徽章进行展示，你只需要填写 Github 用户名和项目名称，网站就会自动获取你项目中的数据。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131257.png)\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604131255.png)\n\n然后你只需要复制链接，将徽章放入你的 README 即可。\n\n## 单元测试\n\n上面所说的开源协议这类徽章基本上只有展示作用，还有一些徽章，用户点击后，可以获取到他们想知道的数据，比如 `build passing`、`coverage 97%` 这些徽章是项目进行 CI（Continuous integration, 持续集成）测试和生成代码覆盖率报告后，展示出来的徽章。当用户点击它们，就可以看到项目 CI 测试的情况和代码覆盖率的报告图。\n\n为什么要展示代码覆盖率？原因很简单，代码覆盖率常常被认为是衡量单元测试好坏的一个指标，而单元测试的好坏在某种程度上又会反应项目代码的质量。因此当项目挂上 `coverage: 100%` 的徽章时，总给人以满满的安全感。\n\n那么为什么要进行单元测试，推荐看一个知乎上的优质回答：[单元测试到底是什么？应该怎么做？](https://www.zhihu.com/question/28729261/answer/163637881)。这里我只简单介绍一下前端单元测试的流程。\n\n前端的单元测试包括但不限于：单元功能测试、UI 测试、兼容性测试等等。一个测试体系大体包括四部分：\n\n- 测试运行器（eg: [karma](https://github.com/karma-runner/karma)）\n- 测试框架（eg: [mocha](https://github.com/mochajs/mocha), [jest](https://github.com/facebook/jest), [jasmine](https://github.com/jasmine/jasmine), [qunit](https://github.com/qunitjs/qunit)）\n- 断言库（eg: [should](https://github.com/shouldjs/should.js), [chai](https://github.com/chaijs/chai)）\n- 代码覆盖率（eg: [istanbul](https://github.com/gotwarlost/istanbul)）\n\n下面我们通过一个单元功能测试的例子来了解如果进行前端单元测试。\n\n> 举的这个例子没有涉及测试运行器，只讲了测试框架、断言库和测试覆盖率的使用。以我个人比较喜欢的 `mocha + should + istanbul` 组合为例。\n\n### 建立项目\n\n首先，执行 `npm init --yes` 创建 package.json 文件。\n\n然后，新建一个 main.js 文件，编写 factorial 函数，用于求一个数的阶乘。\n\n```js\nvar factorial = function(n) {\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n\nif (require.main === module) {\n  // 如果是直接执行 main.js，则进入此处\n  // 如果 main.js 被其他文件 require，则此处不会执行\n  var n = Number(process.argv[2]);\n  console.log(\"factorial(\" + n + \") is\", factorial(n));\n}\n```\n\n这只是简单的实现，我们先运行一下，看看结果是否正确。执行指令：`node main.js 5`，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604172016.png)\n\n结果是 120，符合预期。但是一个测试例子并不能说明什么，我们还需要验证如果输入，负数、非数字、小数、很大的数等等，程序会返回什么。所以接下来我们将进行 **测试驱动开发**（Test-Driven Development, TDD），通过不断的测试来逐步完善我们的代码。\n\n### 运行测试\n\n在 main.js 中添加一句 `exports.fibonacci = fibonacci;` 将函数暴露出去。这样才可以在其他文件中 `require` 这个函数。\n\n在 test 目录下新建测试文件，命名为 `main.test.js`。然后在测试文件中引用 fibonacci 函数，并使用 mocha 和 should 进行测试。\n\n> 测试文件通常放在 test 目录下，文件的命名规则是在原来的文件名后面加 `.test`\n\n```js\nvar main = require(\"../src/main\");\nvar should = require(\"should\");\n\ndescribe(\"test/main.js\", function() {\n  it(\"should equal 0 when n === 0\", function() {\n    main.factorial(0).should.equal(1);\n  });\n});\n```\n\n> 其中 `describe()`、`it()` 是 mocha 提供的 api，看不懂的话先记住就好了。\n\n接着我们来跑通测试文件。\n\n首先全局安装 mocha：`npm install mocha -g`，然后执行指令：`mocha ./test/main.test.js`，结果如下，显示 passing 表明测试通过。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604175056.png)\n\n到这里，我们已经使用测试框架 + 断言库进行了最简单的测试，接下来需要不断完善测试用例来使我们的代码健壮起来。\n\n### 完善测试用例\n\n首先，明确函数功能。我们的 factorial 函数应该有以下功能。\n\n- 当 n === 0 时，返回 1。\n- 当 n > 0 时，返回 `factorial(n - 1) * n`。\n- 当 n < 0 时，抛出错误。因为没有意义。\n- 当 n 不是数字时，抛出错误。\n- 当 n > 10 时，抛出错误。这里为了演示，只进行 10 以内的阶乘运算。\n\n然后，我们需要根据功能来完善测试用例。\n\n```js\ndescribe(\"test/main.js\", function() {\n  it(\"should equal 1 when n === 0\", function() {\n    main.factorial(0).should.equal(1);\n  });\n\n  it(\"should equal 1 when n === 1\", function() {\n    main.factorial(1).should.equal(1);\n  });\n\n  it(\"should equal 3628800 when n === 10\", function() {\n    main.factorial(10).should.equal(3628800);\n  });\n\n  it(\"should throw when n > 10\", function() {\n    (function() {\n      main.factorial(11);\n    }.should.throw(\"n should <= 10\"));\n  });\n\n  it(\"should throw when n < 0\", function() {\n    (function() {\n      main.factorial(-1);\n    }.should.throw(\"n should >= 0\"));\n  });\n\n  it(\"should throw when n is not Number\", function() {\n    (function() {\n      main.factorial(\"参数类型错误\");\n    }.should.throw(\"n should be a Number\"));\n  });\n});\n```\n\n接着，执行测试指令 `mocha ./test/main.test.js`，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604181013.png)\n\n可以看到后面三个测试用例都没有通过，这说明 factorial 函数并不是在所有情况下都可以正常运行。所以我们更新 factorial 的实现。\n\n```js\nvar factorial = function(n) {\n  if (typeof n !== \"number\") {\n    throw new Error(\"n should be a Number\");\n  }\n\n  if (n < 0) {\n    throw new Error(\"n should >= 0\");\n  }\n\n  if (n > 10) {\n    throw new Error(\"n should <= 10\");\n  }\n\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n```\n\n然后再次执行测试指令，效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604191932.png)\n\n完美通过测试。这就是测试驱动开发的流程，首先明确程序的功能，然后跑测试用例，如果测试用例没有通过，修改程序，直到测试用例通过。\n\n### 生成代码覆盖率\n\n有一个指标用于检测编写的测试用例是否合理。这个指标叫做 “代码覆盖率”。它包含四个方面。\n\n- **行覆盖率**：是否每一行都执行了\n- **函数覆盖率**：是否每个函数都调用了\n- **分支覆盖率**：是否每个 if 代码块都执行了\n- **语句覆盖率**：是否每个语句都执行了\n\n这里我们使用 istanbul 来生成代码覆盖率。首先全局安装 istanbul：`npm install istanbul -g`，执行指令：`istanbul cover _mocha`（如果这条指令执行时报错，那就将 mocha 项目级安装：`npm install mocha --save-dev`，然后执行指令：`istanbul cover ./node_modules/mocha/bin/_mocha`）\n\n> 注意，这条指令中 `_mocha` 前面的下划线不能省略。因为，mocha 和 \\_mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n效果如下。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604200739.png)\n\n具体的覆盖率情况，可以运行 `coverage/lcov-report` 目录下的 `index.html` 文件查看。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604201523.png)\n\n其实这次的覆盖率是 100%，因为函数在被其他文件引用时 24、25 这两行不会执行，所以没办法测。如果将这两行所在的 if 语句删除，可以得到 100% 的覆盖率。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604201923.png)\n\n### 上传代码覆盖率\n\n主流的的展示代码覆盖率的工具有 [Codecov](https://codecov.io/) 和 [Coveralls](https://coveralls.io/)。至于选择哪一个，答案是都可以，不过 Coveralls 网站的界面有种古典的气息，相比之下我更喜欢 Codecov，所以这里以 Codecov 为例。\n\n首先，打开 Codecov 官网，绑定 Github 账号之后，选择要展示覆盖率的仓库。\n\n然后，项目级安装 codecov：`npm install codecov --save-dev`。\n\n接着，将上传覆盖率的指令写入 `package.json` 文件。\n\n```json\n\"script\": {\n  \"codecov\": \"cat ./coverage/lcov.info | ./node_modules/.bin/codecov\"\n}\n```\n\n这条指令中 `cat ./coverage/lcov.info` 指令用于读取 coverage 目录下的 `lcov.info` 文件， `./node_modules/.bin/codecov` 指令用于将覆盖率上传到 Codecov 网站。\n\n> 注意，上传覆盖率的指令在本地运行是没有作用的，需要在 CI 中执行才有效。\n\n下面会讲如何在 CI 中上传代码覆盖率。\n\n## 持续集成\n\n了解了单元测试和代码覆盖率后，这还不够，因为我们不可能每次都手动运行测试脚本，我们需要的是自动化测试。这就涉及到了持续集成的概念。\n\n持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n主流的持续集成工具有 [Travis CI](https://travis-ci.org/) 和 [Circle CI](https://circleci.com/)，个人比较喜欢前者，因此这里以 Travis CI 为例。\n\n### Travis CI 的使用\n\n首先，进入官网后，点击 Sign In 按钮绑定 Github。然后在仓库列表中选择你要进行持续集成的仓库，点击按钮启用。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604205207.png)\n\n然后，你需要在项目根目录下创建 `.travis.yml` 文件（如果没有这个文件，Travis 会默认执行 `npm install` 和 `npm test`），配置文件示例如下。\n\n```yml\nlanguage: node_js\n\nnode_js:\n  - 10\n\n# Travis CI cache\ncache:\n  directories:\n    - node_modules\n\ninstall:\n  - npm install\n\nscript:\n  - npm run coverage\n\nafter_success:\n  - npm run codecov\n\nbranches:\n  only:\n    - master\n```\n\n在这个配置文件中，指定了我们代码的语言（languages），语言版本（node_js），构建之前运行什么指令安装依赖包（install），执行测试程序的指令（script），测试指令执行成功后执行的指令（after_success）以及对项目的哪些分支进行测试（branches）。更多的配置请查看 Travis 的[官方文档](https://docs.travis-ci.com/user/tutorial/)。\n\n此外这里还使用了 Travis 的 cache 功能缓存 npm 包，来节省构建时间。\n\n上面配置文件中的 `npm run coverage` 和 `npm run codecov` 指令定义在 `package.json` 文件里。\n\n```json\n\"scripts\": {\n  \"coverage\": \"./node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -R spec\",\n  \"codecov\": \"cat ./coverage/lcov.info | ./node_modules/.bin/codecov\"\n}\n```\n\n此外我们还需要将用到的测试库项目级安装。\n\n``` bash\nnpm install --save-dev codecov istanbul mocha should\n```\n\n> 也就是说，你项目的 package.json 文件中的 `devDependencies` 字段或 `dependencies` 字段里，要有这些用到的库的信息才行，这样 CI 执行 `npm run install` 时，才能安装它们，否则会找不到 `istanbul`、`mocha`、`codecov` 这些指令。\n\n如果你 `.travis.yml` 文件中的 install 字段配置如下。\n\n```yml\ninstall:\n  - npm install\n  - npm install istanbul -g\n  - npm install codecov -g\n```\n\n那么 `npm run coverage` 和 `npm run codecov` 指令就可以修改为。\n\n```json\n\"scripts\": {\n  \"coverage\": \"istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -R spec\",\n  \"codecov\": \"cat ./coverage/lcov.info | codecov\"\n},\n```\n\n也就是说和你自己跑指令时一样，全局安装的依赖包就不需要指定路径。\n\n> 这里建议不要将 mocha 全局安装，而且依赖包最好都项目级安装。\n\n### 带上你的荣誉徽章\n\n实现了 CI，也上传了代码覆盖率，接下来我们只需要将结果以徽章的形式放入 READMD 即可。\n\nTravis 的徽章这样获取。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604225243.png)\n\nCodecov 的徽章这样获取。\n\n![](https://raw.githubusercontent.com/liuyib/picBed/master/hexo-blog/post/20190604225017.png)\n\n每当项目 commit 之后，CI 测试就会自动进行，然后测试的结果就会通过徽章展示在你的项目文档中。\n\n### 跨浏览器集成测试\n\n浏览器端使用的库，在各个浏览器端的兼容性也是非常重要的。一些项目会选择在模拟环境中进行测试，这样虽然方便，但是毕竟是模拟的，测试效果无法媲美真实环境。所以就需要用到跨浏览器测试的工具，有两个选择 [SauceLabs](https://saucelabs.com/) 和 [BrowserStack](https://www.browserstack.com/)，这个工具提供了多重的浏览器环境（包括 PC 端和移动端），帮助你在多种浏览器中自动运行脚本。\n\n关于跨浏览器集成测试更详尽的使用，推荐阅读：[前端持续集成解决方案](https://segmentfault.com/a/1190000007221668#articleHeader3)\n","tags":["前端自动化","单元测试","持续集成","Github徽章"]}]