[{"title":"优雅地修改他人贡献的 Pull Request","url":"/2020/09/19/add-commits-to-others-pr/","content":"\n2019 年，我在 Github 上开源了自己的第一个开源项目 [hexo-theme-stun](https://github.com/liuyib/hexo-theme-stun)，它是一个基于 Hexo 框架的博客主题。值得庆幸的是，在维护期间，有许多 Github 用户为这个项目贡献了 Pull Request。\n\n<!-- more -->\n\n有时，他人提出的 Pull Request 并不能直接被接纳，往往需要一些小的调整：修改错别字、调整代码逻辑、完善文档等等。最直接的，我们可以通过评论，要求贡献者修改。但沟通是有成本的，而且不够及时。\n\n有没有更便捷的方法？直接将自己的 Commit 追加到某个 Pull Request 中？答案是肯定的。\n\n> 对于下文的操作，读者可以先在测试项目中验证，然后再应用到实际项目中。\n\n## Step 1: 克隆项目\n\n首先，将自己的项目克隆下来：\n\n```bash\n$ git clone git@github.com:liuyib/trial-test.git\n```\n\n## Step 2: 添加新的远程仓库\n\n为了修改他人 Fork 的仓库，你需要将其添加到自己的远程仓库列表中：\n\n```bash\n$ git remote add EvanOne0616 https://github.com/EvanOne0616/trial-test.git\n```\n\n现在，当你执行 `git remote -v` 指令时，就可以看到他人 Fork 的仓库，出现在你的远程仓库列表中：\n\n```\n$ git remote -v\norigin  git@github.com:liuyib/trial-test.git (fetch)\norigin  git@github.com:liuyib/trial-test.git (push)\nEvanOne0616     https://github.com/EvanOne0616/trial-test.git (fetch)\nEvanOne0616     https://github.com/EvanOne0616/trial-test.git (push)\n```\n\n## Step 3: 拉取新的远程仓库\n\n```bash\n$ git fetch EvanOne0616\n```\n\n## Step 4: 切换到对应的分支\n\n你需要确认一下，贡献者提出 Pull Request 时所用的分支（如果你不确定他们使用的哪个分支，请看 Pull Request 顶部的信息）：\n\n![PR Meta Info](/assets/posts/add-commits-to-others-pr/pr-meta-info-branch.png)\n\n{% note warning %}\n有可能你会看到，贡献者提出 Pull Request 时所用的分支显示为 `unknown repository`，这是因为在你还未合并 PR 之前，该贡献者就把 Fork 的仓库删除了。此时，你只能选择直接合并 PR（任何人都无法再修改此 PR），或者你可以要求贡献者重新发起一个 PR，并告诉他没有合并之前不要删除 Fork 仓库。\n{% endnote %}\n\n在本地，给该分支起一个不重复的名字，例如 `EvanOne0616-patch`，然后切换到贡献者提出 Pull Request 所用的分支：\n\n```bash\n$ git checkout -b EvanOne0616-patch EvanOne0616/patch-1\n```\n\n## Step 5: 提交修改，推送远程\n\n在本地进行你想要的修改，提交 Commit 后，推送到贡献者 Fork 的仓库：\n\n```bash\n$ git commit -m \"Fix the wrong spelling of the word\"\n$ git push EvanOne0616 HEAD:patch-1\n```\n\n最后，如果一切顺利，你的 Commit 就自动同步到了 Pull Request 的后面：\n\n![Modify Others PR](/assets/posts/add-commits-to-others-pr/add-commit-to-others-pr.png)\n\n## 总结上文\n\n上文详述了指令的具体操作，这里进行总结：\n\n```bash\n# 克隆自己的仓库\n$ git clone git@github.com:liuyib/trial-test.git\n\n# 将贡献者 Fork 的仓库地址，添加为新的远程仓库\n$ git remote add EvanOne0616 https://github.com/EvanOne0616/trial-test.git\n\n# 拉取贡献者的 Commit\n$ git fetch EvanOne0616\n# 切换到贡献者提出 Pull Request 所用的分支\n$ git checkout -b EvanOne0616-patch EvanOne0616/patch-1\n\n# 你在本地修改代码，然后提交\n$ git add .\n$ git commit -m \"Add some changes\"\n\n# 将你的 Commit 提交到贡献者 Fork 的仓库\n$ git push EvanOne0616 HEAD:patch-1\n```\n\n## 其他方式\n\n### 命令行方式\n\n与上文的操作类似，有另一组指令操作也可以实现同样的效果：\n\n```bash\n# 克隆自己的仓库\n$ git clone git@github.com:liuyib/trial-test.git\n\n# 拉取 PR（其中 patch-1 为贡献者提出 PR 所用的分支名，411 是 PR 的 ID）\n$ git pull origin pull/411/head:patch-1\n# 切换到贡献者提出 Pull Request 所用的分支\n$ git checkout patch-1\n\n# 你在本地修改代码，然后提交\n$ git add .\n$ git commit -m \"Add some changes\"\n\n# 将贡献者 Fork 的仓库地址，添加为新的远程仓库\n$ git remote add EvanOne0616 https://github.com/EvanOne0616/trial-test.git\n# 将你的 Commit 提交到贡献者 Fork 的仓库\n$ git push EvanOne0616 patch-1\n```\n\n### 图形化方式\n\n对于上述两组指令操作，开发者可以根据个人喜好自行选择。但是如果需要经常修改他人贡献的 Pull Request，不管哪一种指令操作，都难免会显得有些繁琐。因此，我们需要一种更为简便的方式 —— 图形化操作。\n\n{% note warning no-icon %}\n由于我使用的编辑器是 VS Code，所以对于使用其他编辑器的开发者，下文仅部分有用。\n{% endnote %}\n\n对于图形化 Git 操作，VS Code 已经内置了该功能，在侧边活动栏中可以找到：\n\n![VSCode built-in Git UI](/assets/posts/add-commits-to-others-pr/vscode-built-in-git-ui.png)\n\n{% note success %}\n如果你在 VS Code 的侧边活动栏中，找不到该功能的图标，那么它可能被隐藏了。有两种方式将其显示：1. 在侧边活动栏上，单击鼠标右键，然后勾选【源代码管理】。2. 使用快捷键 <kbd>Ctrl + Shift + G</kbd> <kbd>G</kbd>（该快捷键的使用方法：先按下组合键 <kbd>Ctrl + Shift + G</kbd>，松开所有按键后，再按下 <kbd>G</kbd>）\n{% endnote %}\n\nVS Code 虽然内置了【源代码管理】功能，但是不够强大，因此我们需要安装 [GitLens](https://github.com/eamodio/vscode-gitlens) 插件，两者配合使用。安装 GitLens 之后，在 VS Code 的侧边活动栏中，会新添一个图标，直接点击该图标就可以使用 GitLens 了。\n\n接下来进入正文：“如何通过图形化界面，来修改他人贡献的 Pull Request”。\n\n**1 ) 克隆项目**\n\n将你的项目克隆下来，使用 VS Code 打开，然后点击侧边活动栏的 GitLens 的图标。\n\n**2 ) 添加远程仓库**\n\n点击 Remotes 右面的 `＋`（Add Remote）：\n\n![VSCode Plugins GitLens -- Add Remote](/assets/posts/add-commits-to-others-pr/vscode-plugins-gitlens-add-remote.png)\n\n在弹出的输入框中，输入**远程仓库的名字**（该名字只是一种标识，方便你区分就好，我习惯使用贡献者的 Github 用户名来充当），按下 Enter 确认后，再输入**远程仓库的 URL**（该 URL 有两种方式获取：1. 访问贡献者的仓库列表，找到 Fork 的仓库，复制其 URL。2. 在 Pull Request 最底部，找到 `command line instructions`，点击之后可以看到该 URL）。这样就把贡献者 Fork 的仓库地址，添加到你本地项目的远程仓库列表中了。\n\n**3 ) 拉取 PR 中的代码**\n\n在新添加的 Remote 上单击鼠标右键 -> 点击 Fetch：\n\n![VSCode Plugins GitLens -- Fetch Others](/assets/posts/add-commits-to-others-pr/vscode-plugins-gitlens-fetch-others.png)\n\n接着，找到贡献者提出 Pull Request 所使用的分支（例如 `patch-1`）。然后，点击右边的箭头（Switch to Branch）：\n\n> 该操作的作用是：以远程的分支（例如 `patch-1`）为基础，在本地创建一个新的分支。\n\n![VSCode Plugins GitLens -- Switch Branch](/assets/posts/add-commits-to-others-pr/vscode-plugins-gitlens-switch-branch-to-others.png)\n\n然后在弹出的对话框中，输入一个本地不存在的分支名（例如 `patch-1`），最后确认。此时，如果没有意外的话，Pull Request 中的代码就被拉取到了本地。\n\n{% note default %}\n这里值得一提的是，GitLens 插件的功能如此强大，竟然不支持 `git commit` 的图形化操作。。。具体原因见：[How to commit?](https://github.com/eamodio/vscode-gitlens/issues/375)，其中 GitLens 的维护人员提到：由于 VS Code 内置了 `git commit` 的图形化操作，因此 GitLens 不打算对其进行支持。\n{% endnote %}\n\n**4 ) 修改 PR 并提交**\n\n接下来，根据你自己的想法，在本地修改拉取的 Pull Request 并提交 Commit 信息：\n\n> 注意：下图是用的 VS Code 内置的【源代码管理】功能，不是 GitLens。\n\n![VSCode Plugins GitLens -- Git Add / Commit](/assets/posts/add-commits-to-others-pr/vscode-built-in-git-ui-add-commit.png)\n\n最后，将你的 Commit 推送到贡献者 Fork 的仓库。在 GitLens 中，找到新建的分支（例如 `patch-1`），点击该分支上的 `↑`（Push）-> `Push`：\n\n![VSCode Plugins GitLens -- Git Push](/assets/posts/add-commits-to-others-pr/vscode-plugins-gitlens-push.png)\n\n如果不出意外的话，你的 Commit 就自动同步到了 Pull Request 的后面 🎉。\n\n### Web 方式\n\n还有一种简单的方式，直接在 Github 中在线修改 Pull Request：\n\n![Github PR -- Edit File](/assets/posts/add-commits-to-others-pr/github-pr-files-changed-edit-file.png)\n\n{% note default %}\n该方式一次只能修改一个文件，更适用于需要少量修改的 Pull Request。\n{% endnote %}\n\n## 潜在问题\n\n当你将代码 Push 到贡献者 Fork 的仓库中时，如果遇到类似如下报错信息：\n\n```bash\n! [remote rejected] HEAD -> master (permission denied)\nerror: failed to push some refs to 'https://github.com/EvanOne0616/trial-test.git'\n```\n\n这是因为贡献者在提出的 Pull Request 中，取消勾选了 `Allow edits from maintainers` 选项。让贡献者重新勾选该选项后，该报错即可解决。\n\n## 总结全文\n\n在没有修改过他人贡献的 Pull Request 之前，我并不感觉这有多麻烦。直到我第一次遇到该问题，才发现自己手足无措。于是我 Google 到了这个帖子：[如何修改人家贡献的 PR，不想先合并再修改](https://d.cosx.org/d/420363-pr)，在命令行里跟着这个帖子操作了几遍，并将其中的命令总结下来记在笔记中。此时我的内心是不愿意接受的，自己本以为很简单的事情，没想到这么繁琐。最主要的是，对于开源来说，这是一个常用的操作，如果不能化繁为简，那么时间成本太高，容错率太低。最后，为了简化记忆负担，自己摸索出一套可视化操作的方式，并总结成文，仅供参考 `:)`\n\n---\n\n参考资料：\n\n- [Adding Commits to Someone Else's Pull Request](https://tighten.co/blog/adding-commits-to-a-pull-request/)\n- [Keep your fork synced](https://docs.github.com/en/github/getting-started-with-github/fork-a-repo#step-3-configure-git-to-sync-your-fork-with-the-original-spoon-knife-repository)\n- [如何修改人家贡献的 PR，不想先合并再修改](https://d.cosx.org/d/420363-pr)\n","tags":["Github","Git","Pull Request"],"categories":["版本控制"]},{"title":"深入探究 SSL/TLS 协议","url":"/2020/04/18/deep-study-ssl-tls/","content":"\nSSL/TLS 协议是 HTTPS 中特别重要的一部分，因此有必要深入了解其原理和运作过程。\n\n## HTTP 为什么不安全\n\nHTTP 是明文传输协议，通信过程和数据传输都没有进行加密，也没有验证通信双方的身份。因此通信过程很容易遭到劫持、窃听、篡改等。\n\n<!-- more -->\n\n使用 HTTP 协议传输信息时，就好比邮寄信件，邮件会经过很多快递员，但是每个快递员都可以拆开邮件并读取内容（因为 HTTP 是明文传输的），所以邮件的内容可以被轻易窃取。除此之外，快递员还可以伪造、篡改邮件，使得用户最终收到的邮件是假的。\n\n## HTTPS 如何保证安全\n\nHTTPS = HTTP + SSL/TLS，如今 SSL 已废弃，这里我们只讨论 HTTP + TLS。\n\n为了解决 HTTP 协议的问题，HTTPS 引入了**数据加密**和**身份验证机制**。在开始传输数据之前，通过安全可靠的 TLS 协议进行加密，从而保证后续加密传输数据的安全性。\n\n## TLS 协议\n\n**传输层安全性协议**（Transport Layer Security，**TLS**）及其前身**安全套接层**（Secure Sockets Layer，**SSL**）是一种安全协议，目的是为了保证**网络通信安全**和**数据完整性**。\n\n受 TLS 协议保护的通信过程，具有以下一种或几种属性：\n\n- 连接是安全的\n\n  > 因为传输的数据进行了加密（使用对称加密算法）。并且对称加密的密钥是为每一个连接唯一生成的（基于 TLS 握手阶段协商的[加密算法](https://en.wikipedia.org/wiki/Transport_Layer_Security#Key_exchange_or_key_agreement)和[共享密钥](https://en.wikipedia.org/wiki/Shared_secret)）。\n  >\n  > 其中，**共享密钥**的协商是安全可靠的。如果有攻击者修改了通信，那么该修改一定会被检测出来并被阻止。并且即使攻击者处于整个连接的中间（窃听 TLS 握手），也无法利用窃听到的密钥。\n\n- 连接是可靠的\n\n  > 发送的每条消息都会通过[消息验证码](https://en.wikipedia.org/wiki/Message_authentication_code)（Message authentication code, MAC），来进行消息完整性检查。\n\n- 可以使用公钥对通信双方进行身份验证\n\n  > 该项一般只需要验证一方的身份（通常是服务端）。对于一些非常保密的应用，还是需要验证双方的身份。例如，金融机构往往只允许认证后的用户连入自己的网络。\n\nTLS 协议包括两层：[TLS 记录](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_record)和 [TLS 握手协议](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake)。本文主要讲述 TLS 握手协议。\n\n由于诸多原因（主要是安全方面），SSL 协议的所有版本（SSL 1.0、SSL 2.0、SSL 3.0）都已弃用。并且 TLS 1.0、TLS 1.1 也将在 2020 年弃用，因此目前主流的通信加密协议版本是 TLS 1.2 和 TLS 1.3。\n\n## TLS 握手\n\n一张图解 TLS 握手（下面会详细介绍）：\n\n> 带证书的双向身份验证的 TLS 握手。\n\n![](/assets/posts/deep-study-ssl-tls/tls-four-handshake.png)\n\n> 图片原始来源：[Wikipedia - File:SSL handshake with two way authentication with certificates.svg](https://zh.wikipedia.org/wiki/File:SSL_handshake_with_two_way_authentication_with_certificates.svg)，由我翻译并绘制为中文。\n\n详细过程如下：\n\n- 第一次握手\n\n  - 客户端发送 ClientHello 消息，其中包含**支持的最高 TLS 协议版本**、**随机数**（稍后用于生成“会话密钥”）、**加密算法列表**（如 RSA 公钥加密）和**压缩算法列表**\n\n    > 如果客户端正在尝试恢复握手，则它可以发送会话 ID。\n    >\n    > 如果客户端可以使用[应用协议协商](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation)，则它可能包括受支持的应用程序协议列表，例如 [HTTP 2.0](https://en.wikipedia.org/wiki/HTTP/2)。\n\n  - 服务端回应 ServerHello 消息，其中包含**要使用的 TLS 协议版本**、**随机数**（稍后用于生成“会话密钥”）、**要使用的加密算法**和**要使用的压缩算法**\n\n    > 为了确认恢复握手，则服务端可以发送会话 ID。\n    >\n    > 要使用的协议版本应该是客户端和服务端都支持的最高版本。例如，客户端支持 TLS 1.1，服务端支持 TLS 1.2，则应该选择 TLS 1.1 版本。\n\n- 第二次握手\n\n  - 服务端发送其证书（可选，取决于使用的加密算法）\n\n    > 目前主流的 RSA 算法就是基于证书的。使用证书也是更推荐的做法，因为相比于无证书的机制，使用证书更安全\n\n  - 服务端发送 ServerKeyExchange 消息（可选，取决于使用的加密算法。DHE 和 DH_anon 算法会发送该消息）\n  - 服务端发送 CertificateRequest 消息，请求获取客户端证书，以便进行相互认证（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步）\n  - 服务端发送 ServerHelloDone 消息，表示**服务端握手协商完成**（注意，是协商完成，而不是整个 TLS 握手完成）。\n  - 客户端校验服务端证书（如果证书不合法，客户端会**向用户发出警告信息**并**断开 TLS 握手**）\n\n- 第三次握手\n\n  - 客户端发送其证书，供服务端使用和校验（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步）\n  - 客户端发送 ClientKeyExchange 消息（可选，同样取决于使用的加密算法。DHE 和 DH_anon 算法会用到），其中可能包含 Pre-Master-Secret、公钥。\n\n    > Pre-Master-Secret (PMS，预主密钥) 是一个随机数，在发送之前，会使用服务端证书中的公钥对其进行加密。\n\n  - 客户端发送一个 CertificateVerify 消息（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步），其中包含使用客户端**私钥**对之前握手信息的签名。服务端可以使用客户端公钥来验证此签名，以确定客户端是否拥有此证书\n\n  - 到此为止，客户端和服务端都具有了三个随机数（两个随机数 + PMS），然后它们分别使用之前协商的**对称加密算法**和**三个随机数**来生成 Master-Secret，用于加密之后传输的数据\n\n    > Master-Secret（MS，主密钥，也称为“会话密钥”）\n\n- 第四次挥手\n\n  - 客户端发送 ChangeCipherSpec 记录，用于告诉服务端“之后的所有数据都将进行身份验证（如果服务端证书中存在加密参数，则会进行加密）”。具体如下：\n\n    - 客户端发送经过身份验证和加密的 Finished 消息，其包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)\n    - 服务端尝试解密 Finished 消息，获取并验证 Hash 和 MAC。如果解密或验证失败，则认为握手失败，断开 TLS 链接。\n\n  - 服务端回应 ChangeCipherSpec 记录，同样用于告诉客户端“之后的所有数据都将进行身份验证（如果服务端证书中存在加密参数，则会进行加密）”。具体如下：\n\n    - 服务端发送经过身份验证和加密的 Finished 消息，其包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)\n    - 客户端执行与服务端上一步相同的解密和验证过程\n\n上面对 TLS 四次握手进行了全面的介绍，但比较晦涩难懂，下面我们将其简化并总结一下：\n\n> 由于不用证书的 TLS 握手不够安全，也很少使用，因此这里只讨论需要证书的。\n\n- 第一次握手\n\n  - 客户端发送 TLS 握手请求，其中包含**支持的最高 TLS 协议版本**、**随机数**、**加密算法列表**、**压缩算法列表**\n  - 服务端回应请求，回应的内容包含**要使用的 TLS 协议版本**、**随机数**、**要使用的加密算法**、**要使用的压缩算法**\n\n- 第二次握手\n\n  - 服务端发送其证书，请求获取客户端证书，然后发送 ServerHelloDone 消息\n  - 客户端验证服务端证书，如果不合法，则断开 TLS 握手连接\n\n- 第三次握手\n\n  客户端发送以下信息：\n\n  - 客户端证书\n  - 一个随机数（PMS）。该随机数使用服务端的公钥加密\n  - 使用客户端**私钥**对先前握手信息的签名\n\n  此时，客户端和服务端都有了三个随机数，然后双方各自使用协商的对称加密算法和三个随机数，来生成对话密钥（MS），用于加密之后传输的数据。\n\n- 第四次挥手\n\n  客户端发送如下信息：\n\n  - 编码改变通知（用于告诉服务端加密传输接下来的数据）\n  - 握手结束通知（该通知包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)，供服务端校验）\n\n  服务端发送如下信息：\n\n  - 编码改变通知（用于告诉客户端加密传输接下来的数据）\n  - 握手结束通知（该通知包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)，供客户端校验）\n\n## 证书校验\n\nTLS 协议中重要的一环是如何校验证书的真实性。虽然有些 TLS 握手不需要证书（例如，使用 [Diffie-Hellman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman)（DH） 算法的 TLS 握手），但是这些情况都被证实不安全，而且很少使用。\n\n要证明证书的真实性，通常依赖于**一组**受信任的第三方**证书颁发机构**（Certificate authorities, **CA**）。验证 TLS 证书有效性的方法如下：\n\n1. 检查证书是否是浏览器中**受信任的根证书机构**颁发\n\n   证书都是上级 CA 签发的，上级的 CA 可能还有上级，直到找到根证书。\n\n2. 检查证书中的**证书吊销列表**（CRL），看证书是否已经被吊销\n\n   证书被吊销后，会被记录在证书吊销列表中，CA 会定期发布 CRL。应用程序可以根据 CRL 来检查证书是否被吊销。\n\n3. 通过**在线证书状态协议**（OCSP）检查证书是否有效\n\n   CA 会提供实时的查询接口，用来查询证书的有效性。在线实时查询会使得 TLS 握手时间延长，因为浏览器需要等待查询结束才能继续 TLS 握手。至于使用**在线查询**还是证书中的**吊销列表**，由浏览器决定。\n\n4. 检查证书是否过期\n5. 检查域名和证书中的域名是否一致\n6. 查询网站是否被列入了欺诈网站黑名单\n\n   这一步 IE7 会进行，IE7 会到**欺诈网站数据库**，查询网站是否被列入了欺诈黑名单。\n\n经过了以上步骤，浏览器中才会显示安全锁的标志。任意一个步骤出问题，浏览器都无法建立安全链接，并最终提示“您的链接不是私密链接”。\n\n## 对称加密\n\n对称加密，又叫私钥加密，指**加密和解密使用相同密钥的加密算法**。其特点是，加密密钥和解密秘钥可以相互推算出来。并且在大多数对称加密算法中，加密密钥和解密秘钥是相同的。因此，密钥的保密性对通信的安全性至关重要。\n\n优点：计算量小、加密速度快，效率高。\n缺点：双方使用同样的密钥，安全性得不到保证。\n\n从以上特点可以看出，如果 TLS 握手阶段使用对称加密，那么只要攻击者窃听到密钥，就可以获取所有通信数据，这使得加密毫无意义。因此，需要用到非对称加密来保证 TLS 握手的安全。\n\n## 非对称加密\n\n上文介绍了 TLS 四次握手，我们知道在数据传输之前，需要**通过协商来交换密钥、加密算法等**。密钥协商阶段常用的非对称加密算法是 [RSA](<https://en.wikipedia.org/wiki/RSA_(algorithm)>)（用于生成**公钥**和**私钥**）。其中，公钥会被包含在证书中，私钥则由客户端或服务端自己来保管。\n\nRSA 算法安全性很高，实现也简单，但缺点是需要比较大的质数（目前业界常用的是 2048 位）来保证安全强度，并且运算极其消耗 CPU 资源。\n\n一次完全的 TLS 握手中，在密钥交换阶段，非对称加密的计算量占整个握手过程的 90% 以上，而对称加密的计算量只相当于非对称加密的 0.1% 左右。所以，如果后续的数据传输也使用非对称加密，则会极其消耗 CPU 性能，服务器根本无法承受。\n\n此外，非对称加密有一个限制：**加密的内容长度不能超过公钥的长度**。例如，常用的公钥长度为 2048 位，意味着加密内容不能超过 256 个字节。\n\n因此，非对称加密目前只适用于**密钥协商**或 **CA 签名**，不适用于传输数据的加解密，这也就是为什么不全程使用非对称加密的原因。\n\n## 握手恢复\n\nTLS 握手阶段使用了非对称加密（例如 RSA 算法），其计算消耗非常大，因此 TLS 握手机制中提供了会话恢复的功能，从而提高了握手中断后再次握手的性能。\n\n有两种方法可以恢复会话：一种是 Session ID，另一种是 Session tickets。\n\n### Session ID\n\nSession ID 的思想很简单：每次会话都有一个 Session ID。如果 TLS 握手中断，下次重连的时候，只要客户端给出 Session ID，并且服务端有对应的记录，那么双方就可以使用之前的“会话密钥”，而不必重新计算生成。\n\n具体过程如下：在一次会话中，服务器发送 Session ID 作为 ServerHello 消息的一部分。客户端将此 Session ID 与服务端的 IP、TCP 端口相关联，以便下次重连时简化握手。服务端则会将此 Session ID 与之前协商的密钥相关联，特别是“会话密钥（Master-Secret）”。\n\n### Session tickets\n\nSession ID 机制有一些弊端，例如：1、只能保留在一台服务器上。负载匀衡中，多台服务器之间往往没有同步 Session 信息，如果客户端的两次请求没有被同一台服务器处理，就无法通过 Session ID 恢复握手。2、服务端不好控制 Session ID 对应信息的失效时间。时间太短起不到作用，太长又占用服务器大量资源。\n\nSession tickets 的出现就是为了 Session ID 机制的一些弊端。\n\n使用 Session tickets 时，服务器将**会话状态**存储在其中，然后将 Session tickets 加密后存储到客户端。客户端在恢复会话时，将 Session tickets 发送给服务端，服务器验证通过后，就可以使用其中的会话状态来恢复 TLS 握手。\n\n## TLS 安全性\n\n从 TLS 的原理可知，其设计是严谨、可靠的，但是问题出现在不严谨的使用中。\n\n### 中间人攻击\n\n中间人攻击（Man-in-the-middle, MITM）是指 A 和 B 通信时，有第三者 C 处于信道中间，可以完全劫持、窃听、篡改这些信息。\n\n上文中也一直强调，不使用证书的 TLS 握手是不安全的。例如，使用密钥交换算法 [DH](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman)，该算法就没有证书的概念，这样攻击者就可以轻易窃听、篡改数据，从而冒充他人。\n\n### TLS 剥离攻击\n\nTLS 剥离攻击是指将 HTTPS 连接降级到 HTTP 连接，从而截获用户传输的内容。也属于中间人攻击的一种。\n\n用户在访问网站时，一般只会在地址栏输入域名，例如 `github.com`。这样操作的结果是，浏览器用默认的 HTTP 协议发送请求，服务器会返回 302 状态码，然后客户端进行重定向，这时候才使用 HTTPS 协议去访问网站。\n\n攻击者正是利用 HTTP 重定向到 HTTPS 的过程，进行 TLS 剥离攻击。如下图所示：\n\n![](/assets/posts/deep-study-ssl-tls/tls-strip-attack.png)\n\n在请求第一次走 HTTP 协议时，攻击者劫持 80 端口，然后模拟 HTTPS 请求到服务器上获取数据，最后仍通过 80 端口返回给用户，整个过程用户完全察觉不到。\n\n有两种情况下可能存在 TLS 剥离攻击：\n\n- 用户没有通过 `https://` 的方式输入网址，浏览器会走 HTTP 协议\n- 在 HTTPS 页面中，包含 HTTP 链接\n\n  > 这就是为什么建议 HTTPS 页面中，所有的链接都要使用 HTTPS 协议。哪怕其中有一个链接使用了 HTTP 协议，那么整个 HTTPS 页面都可能是不安全的。\n\n### 伪造证书攻击\n\n上文介绍 TLS 握手时，提到了如果攻击者使用了伪造的证书，那么一定会被检验出来。但是，如果客户端信任攻击者的伪造证书会怎样？结果不言而喻，攻击者可以随意窃取用户的数据。\n\n假设用户访问 `https://github.com`，但是用户的 DNS 服务器被攻击了，使得 IP 并没有指向 Github 的服务器，而是指向了攻击者的服务器。此时，如果攻击者的服务器上有合法的证书，那么客户端就会信任攻击者，从而和攻击者进行通信。\n\n这种攻击的前提条件是：1、**用户的 DNS 服务器被攻击**。2、**攻击者的服务器上有合法的证书**。其中，第二点对于用户来说无法控制，需要证书机构不滥发证书。\n\n在实际中，这种攻击确实发生过，例如：2016 年 Mozilla 发现沃通 CA 存在严重的信任问题，例如偷签 `github.com` 的证书，故意倒填证书日期绕过浏览器对 SHA-1 证书的限制等，将停止信任 WoSign 和 StartCom 签发的新证书。\n\n## 安全措施\n\n### HSTS 策略\n\n为了应对 TLS 剥离攻击，引入了 HSTS 技术。HSTS（HTTP Strict Transport Security）的作用是强制客户端使用 HTTPS 进行通信。\n\n该策略的原理很简单：在服务端的响应头中添加 `Strict-Transport-Security` 字段，该字段中设置了 `max-age`，下次客户端使用 HTTP 访问时，只要 `max-age` 未过期，就直接内部返回 307 状态码（不经过服务器），然后重定向到 HTTPS。\n\n使用示例：\n\n```http\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n```\n\n> `includeSubDomains` 表示对子域名也生效。\n\n这意味着两点：\n\n- 在接下来的 31536000 秒（即一年）中，客户端发起 HTTP 请求时，会自动强制跳转到 HTTPS\n- 在接下来的一年中，如果服务器发送的 TLS 证书无效，用户不能忽略浏览器的警告继续访问网站\n\n使用 HSTS 的一些弊端：\n\n- 用户第一次访问某网站，还没有种下 `Strict-Transport-Security` 响应头，HSTS 策略无法生效\n\n  > 解决这个弊端有两种方法：\n  >\n  > 1. 浏览器预置 HSTS 域名列表\n  > 2. 将 HSTS 信息加入到域名系统记录中（这需要确保 DNS 安全）\n\n- 直接使用 IP 访问，HSTS 策略无法生效\n- 可以改通过修改系统时间绕过 `max-age`\n\n  > 攻击者可以通过伪造 NTP（Network Time Protocol，网络时间协议） 信息，设置错误时间来绕过 HSTS。解决方法是认证 NTP 信息，或者禁止 NTP 大幅度增减时间。\n\n- 如果证书错误，浏览器一般会提醒存在安全风险，但仍然提供继续访问的链接。使用 HSTS 策略后，浏览器就不再提供继续访问的链接了，所以一旦证书配置错误，就会引起很大的故障\n- 如果服务器的 HTTPS 没有配置好就开启了 `Strict-Transport-Security` 响应头，那么在服务器的 HTTPS 配置好之前，用户无法连接到服务器，除非等到 `max-age` 过期或使用 IP 访问\n\n使用 HSTS 的额外收益：节省一次 302/301 重定向请求。\n\n---\n\n参考资料：\n\n- [SSL/TLS 协议运行机制的概述](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n- [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)\n- [从网络协议的角度聊一聊最近 Github 被大规模攻击事件](https://mp.weixin.qq.com/s/AI0mjOZxBx3bRn71CjbY3w?client=tim&ADUIN=1656081615&ADSESSION=1585797524&ADTAG=CLIENT.QQ.5603_.0&ADPUBNO=26933)\n- [SSL/TLS 原理详解](https://www.linuxidc.com/Linux/2016-05/131147.htm)\n- [HTTP over SSL/TLS](https://hit-alibaba.github.io/interview/basic/network/HTTPS.html)\n- [HSTS 学习笔记](https://jjayyyyyyy.github.io/2017/04/27/HSTS.html)\n- [你所不知道的 HSTS](https://www.barretlee.com/blog/2015/10/22/hsts-intro/#comments)\n","tags":["SSL/TLS","HTTPS"],"categories":["Web 安全"]},{"title":"CSS 拷问：水平垂直居中方法你会几种？","url":"/2020/04/07/css-h-and-v-center/","content":"\nCSS 实现水平垂直居中，这是一道经典的面试题，也是我们平时开发经常遇见的问题。本文总结了常用的方法，以及各种奇淫巧技，并且会注明每种方法的兼容性。\n\n<!-- more -->\n\n开始正文之前，我们准备一些元素：\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\">hello world</div>\n</div>\n```\n\n为了便于查看，加上一些样式：\n\n```css\n.outer {\n  width: 300px;\n  height: 300px;\n  border: 1px solid #999;\n}\n\n.inner {\n  width: 100px;\n  height: 100px;\n  border: 1px solid #999;\n}\n```\n\n**上面这些代码会在下文中复用，并且不再提及，请注意记忆。**\n\n## 水平垂直居中\n\n下面是水平和垂直居中都适用的方法：\n\n1. Flex 方案\n2. Grid 方案\n3. `absolute` + `transform`\n4. `absolute` + `calc`\n5. `absolute` + 负 `margin`\n6. `absolute` + `margin: auto`\n7. `writing-mode`\n\n### Flex 方案\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  display: flex;\n  justify-content: center; /* 水平居中 */\n  align-items: center; /* 垂直居中 */\n}\n```\n\n该方案的另一种用法：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  display: flex;\n}\n\n.inner {\n  margin: auto;\n}\n```\n\n目前在移动端已经完全可以使用 Flex 布局了，PC 端需要看自己业务的兼容性情况。\n\n优点：不需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 10+, Chrome 4+, Firefox 2+\n- Android 2.3+, iOS 6+\n\n### Grid 方案\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  display: grid;\n}\n\n.inner {\n  justify-self: center; /* 水平居中 */\n  align-self: center; /* 垂直居中 */\n}\n```\n\n该方案的另一种使用方法：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  display: grid;\n}\n\n.inner {\n  margin: auto;\n}\n```\n\n该方案的兼容性比 Flex 差一点，同样的根据自己业务的兼容情况选择使用。\n\n优点：不需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 10+, Chrome 57+, Firefox 52+\n- Android 6+, iOS 10.3+\n\n### absolute + transform\n\nCSS3 中新增的 `transform`，其 `translate` 属性是根据元素自身计算的。例如：设置 `transform: translateX(-50%);`，元素会向左偏移自身宽度的一半。根据这一特性，很容易实现元素的居中：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  position: relative;\n}\n\n.inner {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n优点：不需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 9+, Chrome 4+, Firefox 3.5+\n- Android 3+, iOS 6+\n\n### absolute + calc\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  position: relative;\n}\n\n.inner {\n  position: absolute;\n  left: calc(50% - 50px);\n  top: calc(50% - 50px);\n}\n```\n\n缺点：需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 9+, Chrome 19+, Firefox 4+\n- Android 4.4+, iOS 6+\n\n### absolute + 负 margin\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  position: relative;\n}\n\n.inner {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -50px;\n  margin-top: -50px;\n}\n```\n\n缺点：需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 6+, Chrome 4+, Firefox 2+\n- Android 2.3+, iOS 6+\n\n### absolute + margin: auto\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  position: relative;\n}\n\n.inner {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n```\n\n该方案的原理是：使用了 CSS 中的定位属性（`absolute`、`fixed` 等）后，如果 `left` 设置了具体值，没有设置 `right` 和 `width`，那么就会自动计算，把剩余的空间分配给 `right` 和 `width`。如果 `left`、`right` 和 `width` 都设置了具体值，并且没有占满横向空间，那么剩余空间就处于待分配状态，此时设置 `margin: auto;` 意味着把剩余的空间分配给 `margin`，并且左右均分，所以就实现了水平居中，垂直方向同理。\n\n但是要知道该方法的副作用：\n\n- `left: 0; right: 0;` 相当于 `width: 100%;`\n- `top: 0; bottom: 0;` 相当于 `height: 100%;`\n\n缺点：需要固定居中元素的宽高，否则其宽高会被设为 `100%`（副作用）。\n\n兼容性：\n\n- IE 6+, Chrome 4+, Firefox 2+\n- Android 2.3+, iOS 6+\n\n### writing-mode\n\n`writing-mode` 可以改变文字显示方向。例如，将文字显示为垂直方向：\n\n```html\n<div>垂直显示</div>\n```\n\n```css\ndiv {\n  writing-mode: vertical-lr;\n}\n```\n\n显示效果如下：\n\n```\n垂\n直\n显\n示\n```\n\n该属性最神奇的地方在于，不仅可以使文字显示方向改变，还能使所有作用于水平方向上的属性，变成作用于垂直方向。所以，通过 `writing-mode` 和 `text-align: center` 就可以实现垂直居中了。\n\n这里，我们需要改造下复用代码中的 DOM 结构：\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\">\n    <div class=\"content\"></div>\n  </div>\n</div>\n```\n\n然后，该方案的核心代码如下：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  writing-mode: vertical-lr;\n  text-align: center;\n}\n\n.inner {\n  display: inline-block;\n  width: 100%;\n  height: auto;\n  writing-mode: horizontal-tb;\n  text-align: center;\n}\n\n.content {\n  display: inline-block;\n  text-align: left; /* 重置文字位置（如果需要） */\n}\n```\n\n缺点：需要修改 DOM 结构（为了居中元素，需要嵌套两层父元素）。\n\n优点：不需要固定居中元素的宽高。\n\n兼容性：\n\n- IE 6+, Chrome 4+, Firefox 3.5+\n- Android 2.3+, iOS 5.1+\n\n## 水平居中\n\n下面介绍只适用于水平居中的方案：\n\n1. `margin: auto`\n2. `text-align` + `inline-block`\n3. `fit-content` + `margin`\n\n### margin: auto\n\n```css\n/* 这里引用复用代码 */\n\n.inner {\n  display: block; /* 还可以是 table | flex | grid，但不能是 inline-xxx */\n  margin: 0 auto;\n}\n```\n\n该方案的原理是：元素被设置成块级后，会独占一行，如果其宽度没有占满横向空间，那么剩余的空间就处于待分配状态，此时设置 `margin: auto;` 意味着把剩余的空间分配给 `margin`，并且左右均分，所以就实现了水平居中。\n\n缺点：需要固定居中元素的宽。\n\n### text-align + inline-block\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  text-align: center;\n}\n\n.inner {\n  display: inline-block;\n  text-align: left; /* 重置文字位置（如果需要） */\n}\n```\n\n该方案的原理是：上面代码中的 `text-align: center;` 会使文本居中，但是对块级元素无效，如果将元素设置为 `inline-block`，该元素就会被当做文本对待，从而实现元素居中。\n\n缺点：为了居中元素，使文本也居中了，因此可能需要重置文本位置。\n\n优点：不需要固定居中元素的宽。\n\n### fit-content + margin\n\n该方案用法有两种，一种是直接应用于元素上，另一种是应用于元素的父元素上。\n\n- 直接应用于元素上\n\n  ```css\n  /* 这里引用复用代码 */\n\n  .inner {\n    width: fit-content;\n    margin: auto;\n  }\n  ```\n\n  缺点：会使元素的宽度改变（同内容宽度）。\n\n- 应用于元素的父元素上\n\n  ```css\n  /* 这里引用复用代码 */\n\n  .outer {\n    width: fit-content;\n    margin: auto;\n  }\n  ```\n\n  优点：即使子元素是浮动元素也适用。\n\n由于目前 `fit-content` 属性兼容性较差，因此该方案不推荐使用。\n\n## 垂直居中\n\n下面介绍只适用于垂直居中的方案：\n\n1. `table-cell` + `vertical-align`\n2. `inline-block` + `line-height`\n3. `inline-block` + `vertical-align`\n\n### table-cell + vertical-align\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  display: table-cell;\n  vertical-align: middle;\n}\n```\n\n优点：不需要固定居中元素的高。\n\n该方案可配合水平居中的方案 1、2，实现水平垂直居中，如下所示：\n\n- 配合水平居中方案 1\n\n  ```css\n  /* 这里引用复用代码 */\n\n  .outer {\n    display: table-cell;\n    vertical-align: middle;\n  }\n\n  .inner {\n    display: block; /* 还可以是 table | flex | grid，但不能是 inline-xxx */\n    margin: 0 auto;\n  }\n  ```\n\n  缺点：需要固定居中元素的宽。\n\n  优点：不需要固定居中元素的高。\n\n- 配合水平居中方案 2\n\n  ```css\n  /* 这里引用复用代码 */\n\n  .outer {\n    display: table-cell;\n    vertical-align: middle;\n\n    text-align: center;\n  }\n\n  .inner {\n    display: inline-block;\n\n    text-align: left; /* 重置文字位置（如果需要） */\n  }\n  ```\n\n  优点：不需要固定居中元素的宽高。\n\n### inline-block + line-height\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  line-height: 300px;\n}\n\n.inner {\n  line-height: initial; /* 重置 */\n  vertical-align: middle;\n  display: inline-block;\n}\n```\n\n众所周知，元素的 `height` 和 `line-height` 相同的时候，会使其文本内容垂直居中。因此该方案利用了这一特点，不过文本内容虽然垂直居中了，但是元素并没有，因此再将元素设置为 `inline-block`，这样元素就会被当做文本对待了。同时由于具有了 `inline` 属性，`vertical-align: middle;` 也就可以生效了。\n\n缺点：需要知道其父元素高度。\n\n优点：不需要固定居中元素的高。\n\n该方案可配合水平居中的方案 2，实现水平垂直居中，如下所示：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  line-height: 300px;\n\n  text-align: center;\n}\n\n.inner {\n  line-height: initial; /* 重置行高 */\n  vertical-align: middle;\n  display: inline-block;\n\n  text-align: left; /* 重置文字位置（如果需要） */\n}\n```\n\n缺点：需要知道其父元素高度。\n\n优点：不需要固定居中元素的宽高。\n\n### inline-block + vertical-align\n\n```css\n/* 这里引用复用代码 */\n\n.outer::after {\n  content: \"\";\n  display: inline-block;\n  vertical-align: middle;\n  height: 100%;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n}\n```\n\n该方案的原理是：在居中元素的父元素上，使用一个伪元素，将这个伪元素设置为 `inline-block` 后，就好像它原来就是一个真正的 DOM 元素，存在于页面上。然后再将居中元素设置为 `inline-block`，根据 `inline-block` 的特性（多个相邻的 `inline-block` 元素会横向并排显示），居中元素会和伪元素横向并排显示。并且设置 `vertical-align: middle;` 后，它们会互相垂直对齐，最后将伪元素高度撑起来 `height: 100%;`，居中元素会对齐伪元素，从而实现了垂直居中。\n\n优点：不需要固定居中元素的高。\n\n该方案可配合水平居中的方案 2，实现水平垂直居中，如下所示：\n\n```css\n/* 这里引用复用代码 */\n\n.outer {\n  text-align: center;\n}\n\n.outer::after {\n  content: \"\";\n  display: inline-block;\n  vertical-align: middle;\n  height: 100%;\n}\n\n.inner {\n  display: inline-block;\n  vertical-align: middle;\n\n  text-align: left; /* 重置文字位置（如果需要） */\n}\n```\n\n优点：不需要固定居中元素的宽高。\n\n## 文章小结\n\n本文介绍的方法中，除了 `fit-content` 方案和 `Grid` 方案兼容性较差，其他的方案都可以在实际项目中使用。每种方案都有其应用场景，应该根据实际业务灵活运用，而不是 Flex 一把梭。\n","tags":["CSS","CSS 布局"],"categories":["CSS 基础"]},{"title":"使用 Karma + Mocha + Chai 搭建 Web 单元测试环境","url":"/2020/03/20/use-karma-mocha-chai-to-test/","content":"\n本文属于对配置项目的总结，不会过多讲解相关知识。阅读正文之前，你需要了解并使用过 webpack、Babel，了解 ES6、CommonJS 规范，了解过前端单元测试。\n\n<!-- more -->\n\n## 适用场景\n\n说明一下本文的适用场景：\n\n1. 项目使用了 ES6 或 CommonJS 等模块化规范，需要打包编译才能在浏览器里运行。\n2. 需要进行 DOM, BOM 相关的单元测试。\n\n如果你的项目不适用于以上两点，那么没必要使用 Karma，直接使用 Jest 或 Mocha + Chai + Istanbul 组合即可。\n\n## 为什么不用 Jest\n\n[Jest](https://jestjs.io/) 是 Facebook 开源的测试框架，简单易用，只需少量的配置即可开始使用。它使用了 JSDOM 模拟浏览器环境来支持测试，提高了性能，但是也带来了 JSDOM 的局限性。最大的问题是：不能方便的在真实的浏览器中测试。因此难免会使得测试结果不那么准确，毕竟模拟环境无法媲美真实环境。\n\n如果项目涉及 DOM，BOM 相关的一些测试，就不必浪费时间在 Jest 上折腾了，直接使用 Karma 手动搭建测试环境反而会更容易。\n\n## 认识 Karma\n\n[Karma](https://karma-runner.github.io/latest/index.html) 是一个开源的测试运行器（Test Runner），它的最大优势是：允许你在多种真实的浏览器环境中测试代码。能够和主流的测试框架（Mocha, Jasmine, QUnit）很好的结合，并且支持 webpack 和 Babel 的使用。\n\n不过，Karma 的配置没有那么简单，其官方文档中，并没有介绍如何从 0 到 1 进行配置，因此对新手来说不够友好。\n\n## 使用 Karma\n\n在本文中，我们会用 NPM 来管理依赖包，所以先初始化它的配置文件 `package.json`：\n\n```bash\n$ npm init -y\n```\n\n> `-y`（`--yes`）参数表示不进行询问，直接使用默认的配置。\n\n然后，项目级安装 Karma：\n\n```bash\n$ npm install --save-dev karma\n```\n\n为了方便使用，我们将其全局安装一下（这里也可以不全局安装，直接跳过）：\n\n```bash\n$ npm install --global karma\n```\n\nKarma 配置文件的命名规则是 `[name].conf.js`。你可以选择手动编写 Karma 的配置文件，不过更推荐使用 CLI 来自动生成：\n\n```bash\n# 如果你全局安装了 Karma，执行这个\n$ karma init ./karma.conf.js\n\n# 如果你没有全局安装 Karma，执行这个\n$ ./node_modules/.bin/karma init ./karma.conf.js\n```\n\n接下来，根据一系列的提问进行选择（本文选择的内容如图所示）：\n\n![](/assets/posts/use-karma-mocha-chai-to-test/karma-init.png)\n\n1. 想要使用的测试框架 `mocha` 或 `jasmine`\n   > 两者选其一即可，也可以指定其它的，本文以 `mocha` 为例。\n2. 你的项目是否用到了 `Require.js`\n   > [Require.js](http://www.requirejs.org/) 是异步加载规范（AMD）的实现。如果你不清楚，直接选 `no`。\n3. 想要测试的浏览器环境\n   > 可选值：`Chrome`, `ChromeHeadLess`, `ChromeCanary`, `Firefox`, `Safari`, `IE`, `Opera`, `PhantomJS`。\n   > 可以指定单个或多个，本文以 `Chrome` 为例。\n4. 源文件和测试文件的路径\n   > 先输入源文件的路径：`src/**/*.js`（举例），回车之后，再输入测试文件的路径：`test/**/*.js`（举例）\n5. 需要排除的文件\n6. 是否允许 Karma 监听所有文件的变动，并在文件发生变动时，重新执行测试\n\n根据上面选择的项，会自动生成以下内容（这里去掉了默认注释，并加上了中文注释）：\n\n```js\n// karma.conf.js\n\nmodule.exports = function(config) {\n  config.set({\n    // 路径前缀\n    basePath: \"\",\n\n    // 用到的库或框架\n    // 添加到这里表示注册为全局变量（不用反复在代码中 import 或 require）\n    frameworks: [\"mocha\"],\n\n    // 需要提供给浏览器的源文件和测试文件\n    files: [\"src/**/*.js\", \"test/**/*.js\"],\n\n    // 需要排除的文件\n    exclude: [],\n\n    // 将文件提供给浏览器之前，进行预处理\n    preprocessors: {},\n\n    // 测试信息报告器\n    reporters: [\"progress\"],\n\n    // 在浏览器中运行的端口\n    port: 9876,\n\n    // 是否将输出信息彩色显示（用于 reporters 和日志信息）\n    colors: true,\n\n    // 显示日志的级别\n    logLevel: config.LOG_INFO,\n\n    // 是否监听所有文件的变动\n    autoWatch: true,\n\n    // 需要测试的浏览器环境\n    browsers: [\"Chrome\"],\n\n    // 如果为 true 的话，Karma 将捕获浏览器，运行测试，并自动退出\n    // 使用持续集成时会用到该选项（这里先默认，后面会说明）\n    singleRun: false,\n\n    // 允许同时启动的浏览器个数，默认无限个\n    concurrency: Infinity\n  });\n};\n```\n\n## 安装插件\n\n初始化 Karma 的配置文件后，首先需要根据你选择的内容，安装相关插件：\n\n1. 本文选择了 Mocha 测试框架，需要安装 `mocha` 和 `karma-mocha` 插件：\n\n   ```bash\n   $ npm install --save-dev mocha karma-mocha\n   ```\n\n   > 其中 `karma-mocha` 的作用是让 `mocha` 可以在 Karma 中工作。\n\n2. 测试的浏览器我选择了 Chrome，需要安装 `karma-chrome-launcher` 插件：\n\n   ```bash\n   $ npm install --save-dev karma-chrome-launcher\n   ```\n\n   > 该插件用于在测试的时候，自动控制对应的浏览器，你不需要对浏览器进行任何操作，因为 Karma 仅仅是借用浏览器的环境而已。\n   >\n   > 如果你选择了其他浏览器，安装对应的插件即可。例如选择 FireFox，则需要安装 `karma-firefox-launcher` 插件。\n\n这里只是安装了最基本的插件，其它插件的安装会在后面用到时说明。\n\n为了方便读者，我为本文建了一个 Github 仓库：[\nliuyib/karma-mocha-demo](https://github.com/liuyib/karma-mocha-demo)。如果某些修改的地方不太清楚，可以参考该仓库中的 commit 记录。到此为止，本文示例中所做的修改在[这里](https://github.com/liuyib/karma-mocha-demo/commit/cfb20fd3a663bfe819350895edb9944d0cceb8b8)查看。\n\n## 编写代码\n\n为了使本文的示例更具有参考性，这里新建两个模块 `utils.js` 和 `main.js`。\n\n在 `src` 目录下，新建 `utils.js`，编写如下代码：\n\n```js\n// utils.js\n\n// 一个加法函数，返回两数之和\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n然后，在 `src` 目录下，新建 `main.js`，编写如下代码：\n\n```js\n// main.js\n\nimport { add } from \"./utils\";\n\nvar main = function(selector) {\n  var elem = document.querySelector(selector);\n\n  elem.addEventListener(\"click\", function() {\n    var value = parseInt(elem.innerText, 10);\n    elem.innerText = add(value, 1);\n  });\n};\n\nexport default main;\n```\n\n上面这段代码的作用不难看出，就是根据传入的选择器获取 DOM 元素，然后监听该元素的 `click` 事件，当用户点击时，将该元素内容 + 1（为了方便演示，假设该元素内容是数字）。\n\n下文中我们会介绍到，如何测试“DOM 相关的操作”和“需要用户交互的逻辑”。\n\n## 使用 Babel\n\n由于我们的代码中用到了 ES6 语法，所以需要用 Babel 编译一下，安装 Babel 和 webpack 相关插件：\n\n```bash\n$ npm install --save-dev @babel/core @babel/preset-env babel-loader webpack\n```\n\n> 这里安装的依赖版本分别为 `babel 7.x` | `babel-loader 8.x` | `webpack 4.x`\n>\n> 详见：https://github.com/babel/babel-loader#install\n\n- `@babel/core`（旧版名称 `babel-core`，已废弃，不推荐）：是 Babel 语法分析的核心，很多 Babel 插件依赖于它。\n- `@babel/preset-env`（旧版名称 `babel-preset-env`，已废弃，不推荐）：会检测你的配置或运行环境，将代码编译到合适版本。\n- `babel-loader`：允许你使用 Babel 和 webpack 转译 JavaScript 文件。\n- `webpack`：负责打包编译。\n\n> 如果使用 CommonJS 规范，并且想要运行在浏览器中，那么也需要使用 Babel 编译。\n\n## 配置 webpack\n\n首先，我们需要安装 `karma-webpack` 插件：\n\n```bash\n$ npm install --save-dev karma-webpack\n```\n\n> 该插件的作用是让 `webpack` 可以在 Karma 中工作。\n\n然后，参照该插件的[文档](https://github.com/webpack-contrib/karma-webpack)进行配置，修改 `karma.conf.js` 文件：\n\n```js\n...\npreprocessors: {\n  // 匹配源文件，并使用 webpack 进行预处理\n  'src/**/*.js': ['webpack'],\n  // 匹配测试文件，并使用 webpack 进行预处理\n  'test/**/*.js': ['webpack']\n},\n...\n```\n\n上面的配置作用是：在文件提供给浏览器运行之前，使用 webpack 进行预处理。当然你可以继续添加其它插件来处理文件，用法同上，即：`['插件名称', '插件名称', ...]`。\n\n接下来，你需要自己配置 webpack，在 `karma.conf.js` 文件里添加 `webpack: {}` 配置项，然后参照 webpack [文档](https://webpack.js.org/concepts/)进行配置，下面是一些配置示例。\n\n如果你的项目只需要把 ES6+ 语法编译到 ES5，那么只进行下面的配置即可，修改 `karma.conf.js` 文件：\n\n```js\n...\nwebpack: {\n  mode: 'development',\n  module: {\n    rules: [\n      {\n        // 匹配 JavaScript 文件\n        test: /\\.js$/,\n        // 排除 node_modules 和 bower_components 目录\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          // 使用的 loader\n          loader: 'babel-loader',\n          // 传递给 babel-loader 的参数\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      }\n    ]\n  }\n},\n...\n```\n\n其中，传递给 `babel-loader` 的参数，更**推荐**写入 `.babelrc` 文件中：\n\n```js\n// .babelrc\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n对于本文的示例代码来说，只需要将 ES6+ 语法编译到 ES5，上面的配置足够使用。因此，如果你需要更复杂的配置，请自行查看 webpack 的文档。\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/fc4c77e421c9ae297c604418bfb1697c94b12817)，查看所做的修改。\n\n## 启动 Karma\n\n在 `package.json` 中添加一条 NPM 指令：\n\n```json\n...\n\"script\": {\n  \"test\": \"karma start ./karma.conf.js\"\n},\n...\n```\n\n然后在命令行中执行 `npm run test`，如果控制台中没有报错信息，并且 Karma 自动打开了你选择的浏览器，证明你的上述配置没有问题。否则，你需要检查之前的配置是否正确。\n\n## 编写测试代码\n\n首先，安装断言库 `chai` 和 `karma-chai`：\n\n```bash\n$ npm install --save-dev chai karma-chai\n```\n\n> 其中 `karma-chai` 的作用是让 `chai` 可以在 Karma 中工作。\n\n然后全局引入 Chai，修改 `karma.conf.js` 文件：\n\n```js\n...\nframeworks: ['mocha', 'chai'],\n...\n```\n\n你也可以不全局引入，那么你必须在文件中，手动进行 `import` 或 `require`：\n\n```js\nimport { expect } form 'chai';         // ES6\n// 或\nconst expect = require('chai').expect; // CommonJS\n```\n\n通常，测试文件与所要测试的源文件同名，但是后缀名为 `.test.js`（表示测试）或 `.spec.js`（表示规格）。\n\n接下来，我们开始编写测试代码。首先来测试 `utils` 模块，在 `test` 目录下，新建 `utils.test.js`：\n\n```js\n// utils.test.js\n\nimport { add } from \"../src/utils\";\n\ndescribe(\"utils::add test\", function() {\n  it(\"should 3 when add(1, 2) return\", function() {\n    expect(add(1, 2)).to.equal(3);\n  });\n});\n```\n\n上述代码中：\n\n- `describe` 块称为“测试套件（test suite）”，表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。\n\n- `it` 块称为“测试用例（test case）”，表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。\n\n本文使用了 expect 风格的断言，其特点是更接近自然语言。例如上面的代码中：`expect(add(1, 2)).to.equal(3)`，意思是“期望 `add(1, 2)` 等于 `3`”。如果这个断言为真，则对应测试用例通过，否则不通过。\n\n然后，再来测试 `main` 模块，在 `test` 目录下，新建 `main.test.js`：\n\n```js\n// main.test.js\n\nimport main from \"../src/main\";\n\ndescribe(\"main::DOM test\", function() {\n  // 钩子函数\n  beforeEach(function() {\n    // 向页面的 body 元素中添加 DOM 元素，来辅助测试\n    document.body.innerHTML = '<button id=\"btn\">0</button>';\n\n    main(\"#btn\");\n  });\n\n  it(\"should 1 when button is clicked once\", function() {\n    // 获取前面添加的元素\n    var btn = document.querySelector(\"#btn\");\n    // 模拟用户点击\n    btn.click();\n\n    expect(btn.innerText).to.equal(\"1\");\n  });\n});\n```\n\n> 上述代码中，`beforeEach` 是 Mocha 提供的钩子函数，作用是：在每个测试用例（`it` 块）执行之前，都会执行一次。\n>\n> 类似的 Mocha 提供的钩子函数总共有四个：`before`, `after`, `beforeEach`, `afterEach`。它们的具体作用这里不再介绍。\n\n如果想要测试 DOM 相关的操作，我们需要在测试之前，向页面中添加需要用到的元素，例如上述示例代码中的 `document.body.innerHTML = '<button id=\"btn\">0</button>';`。\n\n接着，我们在测试用例（`it` 块）中，获取了提前添加好的 DOM 元素，然后通过 `btn.click();` 来主动触发该元素的点击事件，从而模拟了用户操作。\n\n最后，进行断言来完成测试：`expect(btn.innerText).to.equal('1');`。\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/69748d28ac7cf17b6ac761fb3629055aa88590f2)，查看所做的修改。\n\n## 汇报测试结果\n\n编写完测试代码后，执行测试指令 `npm run test`，Karma 会使用默认的报告器来汇报测试结果，如图所示：\n\n![](/assets/posts/use-karma-mocha-chai-to-test/karma-default-reporter.png)\n\n{% note success %}\n如果你想使用默认的报告器，请直接跳过下面这段。\n{% endnote %}\n\n这里列举几个常用的报告器插件：\n\n- [karma-spec-reporter](https://github.com/mlex/karma-spec-reporter)\n- [karma-mocha-reporter](https://github.com/litixsoft/karma-mocha-reporter)\n- [karma-nyan-reporter](https://github.com/dgarlitt/karma-nyan-reporter)\n\n> 查看更多报告器插件请访问：[https://npmjs.org/browse/keyword/karma-reporter](https://npmjs.org/browse/keyword/karma-reporter)\n\n> 注意，这些插件的文档中指出了 `karma.conf.js` 中的 `plugins` 配置项。一般情况下，以 `karma-` 开头命名的插件，会自动被 Karma 引入，所以一般你不需要指定 `plugins` 配置项。但要知道，一旦你设置了 `plugins` 配置项，就必须引入**所有**以 `karma-` 开头的插件，否则请直接留空。\n\n本文以 `karma-spec-reporter` 作为示例，首先安装插件：\n\n```bash\n$ npm install --save-dev karma-spec-reporter\n```\n\n配置也很简单，只需要修改 `karma.conf.js` 文件：\n\n```js\n...\nreporters: ['spec'],\n...\n```\n\n然后执行 `npm run test`，控制台会输出 “哪些测试用例通过了，哪些没通过”，如图所示：\n\n![](/assets/posts/use-karma-mocha-chai-to-test/karma-spec-reporter.png)\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/5db1630e08f9bfb73b781ee410e5acedda2ac6e8)，查看所做的修改。\n\n## 生成覆盖率报告\n\n这里列举两个常用的生成覆盖率的插件：\n\n- [karma-coverage](https://github.com/karma-runner/karma-coverage)\n- [karma-coverage-istanbul-reporter](https://github.com/mattlewis92/karma-coverage-istanbul-reporter)\n\n其中 `karma-coverage` 是官方的插件，而 `karma-coverage-istanbul-reporter` 基于它进行了一些改进。在我使用的过程中，体验到它俩最大的不同是：生成 `text` 和 `text-summary` 类型的报告方式不同。前者会将这两种类型的报告生成到文件中，而后者会将这两种类型的报告生成到控制台中。本文以 `karma-coverage` 作为举例。\n\n首先，安装 `karma-coverage` 插件：\n\n```bash\n$ npm install --save-dev karma-coverage\n```\n\n然后，参照该插件的[文档](https://github.com/karma-runner/karma-coverage)进行配置，修改 `karma.conf.js` 文件：\n\n```js\n...\npreprocessors: {\n  'src/**/*.js': ['webpack', 'coverage'],\n  'test/**/*.js': ['webpack']\n},\n\nreporters: ['spec', 'coverage'],\n\ncoverageReporter: {\n  // 生成报告的目录\n  dir: 'coverage/',\n  // 要生成的报告类型\n  reporters: [\n    { type: 'lcov', subdir: '.' },\n    { type: 'text', subdir: '.', file: 'text.txt' },\n    { type: 'text-summary', subdir: '.', file: 'text-summary.txt' }\n  ]\n},\n...\n```\n\n执行测试指令 `npm run test`，会生成 `coverage` 目录，并在该目录下生成覆盖率报告。\n\n> 这里需要介绍一下几种常用的报告类型：\n>\n> - `html` 报告类型\n>   这是给人看的覆盖率报告。默认会生成一个 `lcov-report` 文件夹。\n> - `lcovonly` 报告类型\n>   这是给 CI 用的，默认生成的文件名为 `lcov.info`。\n> - `lcov` 报告类型\n>   该报告类型 == `html` 报告类型 + `lcovonly` 报告类型\n> - `text-summary` 报告类型（效果如下）\n>   ```\n>   =============================== Coverage summary ===============================\n>   Statements   : 54.02% ( 47/87 )\n>   Branches     : 19.23% ( 10/52 )\n>   Functions    : 56.52% ( 13/23 )\n>   Lines        : 61.64% ( 45/73 )\n>   ================================================================================\n>   ```\n> - `text` 报告类型（效果如下）\n>   ```\n>   ----------|----------|----------|----------|----------|-------------------|\n>   File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n>   ----------|----------|----------|----------|----------|-------------------|\n>   All files |    54.02 |    19.23 |    56.52 |    61.64 |                   |\n>    main.js  |    54.55 |    19.23 |    58.33 |    62.16 |... 69,70,71,72,73 |\n>    utils.js |    53.49 |    19.23 |    54.55 |    61.11 |... 69,70,71,72,73 |\n>   ----------|----------|----------|----------|----------|-------------------|\n>   ```\n>   一般情况下，常用的报告类型就是 `lcov`, `text`, `text-summary` 这三种。你可以访问[这里](https://istanbul.js.org/docs/advanced/alternative-reporters/)，查看所有报告类型的格式和作用。\n\n找到 `coverage/lcov-report` 目录中的 `index.html` 文件，将其在浏览器中运行，可以查看到详细的覆盖率报告信息，如图所示：\n\n![](/assets/posts/use-karma-mocha-chai-to-test/coverage-in-browser-1.png)\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/0b70ec801aabdfd60ddd4e5c0b17e089c51872bd)，查看所做的修改。\n\n本文的示例代码中，理论上测试覆盖率应该是 100%，但是实际并没有这么多。而且，细心的话可以发现，代码的总行数也变多了，这是因为 webpack 会在编译之后加入一些代码，影响了覆盖率。为了解决这个问题，有两个插件可供选择：\n\n- [babel-plugin-istanbul](https://github.com/istanbuljs/babel-plugin-istanbul)\n- [istanbul-instrumenter-loader](https://github.com/webpack-contrib/istanbul-instrumenter-loader)\n\n如果你的项目只使用了 Babel，没有使用 webpack，那么你只能使用 `babel-plugin-istanbul` 来解决这个问题。如果你的项目使用了 webpack，那么两个插件可以任选其一来使用。\n\n由于本文示例中用到了 webpack，所以这两个插件可以任选其一，我们以 `babel-plugin-istanbul` 为例：\n\n首先，安装该插件：\n\n```bash\n$ npm install --save-dev babel-plugin-istanbul\n```\n\n然后，参照其文档进行配置，修改 `karma.conf.js` 文件：\n\n```diff\n...\nwebpack: {\n  mode: 'development',\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env'],\n+           plugins: ['istanbul']\n          }\n        }\n      }\n    ]\n  }\n},\n...\n```\n\n如果将该配置放入 `.babelrc` 文件，则如下所示：\n\n```diff\n// .babelrc\n{\n  \"presets\": [\"@babel/preset-env\"],\n+ \"plugins\": [\"istanbul\"]\n}\n```\n\n再次执行测试指令 `npm run test`，即可得到 100% 的覆盖率，如图所示：\n\n![](/assets/posts/use-karma-mocha-chai-to-test/coverage-in-browser-2.png)\n\n> 如果你使用 `karma-coverage-istanbul-reporter` 插件来生成覆盖率，可能会遇到覆盖率信息全为 `0` 或 `Unknown` 的情况。这个问题和上述覆盖率统计不正确类似，都是由于插件默认无法统计 ES6+ 代码引起的。你只需要按照上文中的说明，使用 `babel-plugin-istanbul` 或 `istanbul-instrumenter-loader` 插件即可解决此类问题。\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/8ec8303fd703a9681ca6b3f96ff1bab5a3ba8495)，查看所做的修改。\n\n## 持续集成\n\n常用的持续集成工具有 [Travis CI](https://travis-ci.com/) 和 [CircleCI](https://circleci.com/)。本文以 Travis CI 作为举例。\n\n### 配置 Travis CI\n\n由于 Travis CI 是在命令行中运行，因此跑不了 GUI 程序。如果要在 Travis CI 中运行需要 GUI 的测试，则要用到 `xvfb`（X Virtual Framebuffer）来模拟显示。详见：[Using xvfb to Run Tests That Require a GUI](https://docs.travis-ci.com/user/gui-and-headless-browsers/#using-xvfb-to-run-tests-that-require-a-gui)。\n\n新建 Travis CI 的配置文件 `.travis.yml`，并编写以下内容：\n\n```yaml\nlanguage: node_js\n\nnode_js:\n  - 10\n\n# 使用 xvfb 来模拟显示 GUI\nservices:\n  - xvfb\n\n# 指定要使用的浏览器以及版本\naddons:\n  chrome: stable\n\nscript:\n  - npm run test\n\nafter_script:\n  - npm run codecov\n```\n\n除了配置 Travis CI 外，我们还需要配置 Krama，修改 `karma.conf.js` 文件：\n\n> 如果你不准备使用 CI，请忽略该配置，默认即可。\n\n```js\n...\n// 如果设为 true 的话，Karma 将捕获浏览器，运行测试，并自动退出\n// process.env.CI 是环境变量，在 CI 中值为 true，否则值为 false\nsingleRun: !!process.env.CI,\n...\n```\n\n该配置项默认为 `false`，会使得 Karma 在测试结束后仍然监听文件变化，不会退出测试，但是在 CI 中必须在测试结束后退出测试，否则 CI 将会一直等待，直到超时。\n\n### 上传覆盖率\n\n生成了覆盖率，配置了 CI，最后还需要做的是，将覆盖率上传到 [Coveralls](https://coveralls.io/) 或 [Codecov](https://codecov.io/) 中进行分析。本文以 Codecov 为例。\n\n首先，安装 `codecov` 插件：\n\n```bash\n$ npm install --save-dev codecov\n```\n\n然后，参照该插件的[文档](https://github.com/codecov/codecov-node)进行配置，添加一个 NPM 指令，修改 `package.json` 文件：\n\n```diff\n...\n\"script\": {\n  \"test\": \"karma start ./karma.conf.js\",\n+ \"codecov\": \"./node_modules/.bin/codecov\"\n},\n...\n```\n\n该指令的作用是：读取 `coverage` 目录中的 `lcov.info` 文件，然后上传到 Codecov 网站。\n\n> 在上传覆盖率之前，你最好确认一下当你执行 `npm run test` 指令后，可以在 `coverage` 目录中生成 `lcov.info` 文件。\n\n> 到此为止，读者可以访问[这里](https://github.com/liuyib/karma-mocha-demo/commit/cef265c71b6d0c002cd83863d53a434d8a0e01fe)，查看所做的修改。\n\n### 展示徽章\n\n最后，我们把测试的结果，以 Travis CI 和 Codecov 徽章的形式放入 README。例如，本文配套的 Github 仓库 [karma-mocha-demo](https://github.com/liuyib/karma-mocha-demo) 的测试结果：\n\n[![Travis CI](https://img.shields.io/travis/liuyib/karma-mocha-demo.svg)](https://travis-ci.com/github/liuyib/karma-mocha-demo)\n[![Codecov](https://img.shields.io/codecov/c/github/liuyib/karma-mocha-demo.svg)](https://codecov.io/gh/liuyib/karma-mocha-demo)\n\n对应代码如下：\n\n```md\n[![Travis CI](https://img.shields.io/travis/liuyib/karma-mocha-demo.svg)](https://travis-ci.com/github/liuyib/karma-mocha-demo)\n[![Codecov](https://img.shields.io/codecov/c/github/liuyib/karma-mocha-demo.svg)](https://codecov.io/gh/liuyib/karma-mocha-demo)\n```\n\n将其中的用户名（`liuyib`）和仓库名（`karma-mocha-demo`）换成你的即可。\n\n---\n\n参考资料：\n\n- [搭建 Karma+Mocha+Chai 测试 TypeScript 项目](https://blog.crimx.com/2019/06/19/%E6%90%AD%E5%BB%BA-karma-mocha-chai-%E6%B5%8B%E8%AF%95-typescript-%E9%A1%B9%E7%9B%AE/)\n- [测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)\n- [学习 Karma+Jasmine+istanbul+webpack 自动化单元测试](https://www.cnblogs.com/tugenhua0707/p/8433847.html)\n- [使用 Karma + Jasmine 构建 Web 测试环境](https://www.ibm.com/developerworks/cn/web/wa-lo-use-karma-jasmine-build-test-environment/index.html)\n- [Travis CI XVFB Breaking Change](https://benlimmer.com/2019/01/14/travis-ci-xvfb/)\n","tags":["单元测试","Karma","Mocha","Chai"],"categories":["项目搭建"]},{"title":"集成 Pjax 实现网站无刷新加载","url":"/2019/09/24/use-pjax-to-your-site/","content":"\n一般情况下，当我们点击一个网页链接后，浏览器就会努力发送网络请求，然后将请求到的网页渲染出来。有时，我们经常会在一个网站中不停地点击链接，然后网页不停地跳转。通常，浏览器会对文件资源进行一定的缓存，这样使得同一个网站之间的页面跳转时，能够更快的加载。\n\n<!-- more -->\n\n虽然浏览器对资源的缓存加快了页面的加载速度，但是页面每一次跳转时，都会整体刷新一次，这一定程度上降低了用户体验。为了解决这一问题，我们可以使用 Pjax 实现网站无刷新加载。\n\n## Pjax 原理\n\n首先要知道 `Pjax = Ajax + pushState`。当用户进行超链请求时，Pjax 会拦截请求，然后触发 Ajax 请求和 `pushState`。其中，Ajax 使你的页面局部刷新，`pushState` 用于修改 URL 而不跳转页面，从而实现不跳转页面局部刷新的功能。\n\n## 开始使用\n\nPjax 有依赖和不依赖 jQuery 的两种版本：\n\n- [defunkt/jquery-pjax](https://github.com/defunkt/jquery-pjax)【依赖于 jQuery】\n- [MoOx/pjax](https://github.com/MoOx/pjax)【推荐】\n\n这里以不依赖 jQuery 的 [MoOx/pjax](https://github.com/MoOx/pjax) 作为教程。\n\n### 引用文件\n\n为了方便，这里直接使用 JSDelivr 公共的 CDN 地址：\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/pjax/pjax.js\"></script>\n```\n\n### 分析页面\n\n在网站页面切换时，有些部分是不变的，有些是改变的。我们需要根据网站的 DOM 结构自行分析。举个例子，假设页面的结构如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Liuyib's Blog</title>\n    <meta name=\"description\" content=\"Liuyib's Blog\" />\n  </head>\n  <body>\n    <header id=\"header\" class=\"header\">\n      顶部栏...\n    </header>\n    <main id=\"main\" class=\"main\">\n      主体部分...\n    </main>\n    <footer id=\"footer\" class=\"footer\">\n      底部栏...\n    </footer>\n  </body>\n</html>\n```\n\n每次切换页面时，`title` 会随之改变，`header` 和 `footer` 一般不变，而 `main` 是网站的主体部分，也会改变。因此，我们可以这样来使用 Pjax：\n\n```js\nvar pjax = new Pjax({\n  // 这里填写页面中改变的部分（和 CSS 选择器用法一样）\n  selectors: [\"head title\", \"#main\"],\n});\n```\n\n这样，就实现了一个最简单的 Pjax 网站，不过这才刚开始。下面是一些常用的参数：\n\n- `elements`：默认值 `a[href], form[action]`\n\n  指定应用 Pjax 的链接。\n\n- `switches`：默认值 `{}`\n\n  使用旧元素替换新元素。\n\n- `history`：默认值 `true`\n\n  是否启用 `pushState`。禁用后 Pjax 就变成了 Ajax。\n\n- `scrollTo`：默认值 `0`\n\n  页面切换后到顶部的距离。设为 `false` 表示页面保持在切换前的位置。\n\n- `scrollRestoration`：默认值 `true`\n\n  切换页面后，Pjax 将尝试恢复滚动位置。\n\n- `cacheBust`：默认值 `true`\n\n  是否在 URL 上添加时间戳，防止浏览器缓存。\n\n关于这些参数的作用和设置，根据需要自行选择。更多参数，请查看 MoOx/pjax 项目的 [READMD](https://github.com/MoOx/pjax)。\n\n### 添加进度条\n\n使用了 Pjax 后，在进行页面跳转时，浏览器没有任何加载提示，并且在跳转完成之前，页面不会有任何变化，因此在网速比较慢的情况下，我们可能会以为页面并没有进行跳转。为了改善体验，可以添加一个进度条，以此来告诉用户“页面正在加载”。\n\n说到这里，就不得不提到 Github 的加载进度条。如果心细的同学可能会发现，Github 也使用了 Pjax。那么下面我们仿照 Github 来实现一个 Pjax 加载进度条吧。\n\n首先要清楚一点，这里要实现的加载进度条实际上是**假的**，也就是说，页面实际加载了多少我们并没有办法知道，进度条也只是按照一定的速度增加的。\n\n> 如果可以控制服务端的话，可以做出**真的**加载进度条，至少在 Github Pages 上还暂时做不到。\n\nHTML (Pug):\n\n```pug\ndiv.loading-bar\n  div.progress\n```\n\nCSS (Stylus):\n\n```stylus\n.loading-bar {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 99999;\n  opacity: 0;\n  transition: opacity .4s linear;\n\n  .progress {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 0;\n    height: 2px;\n    background-color: #77b6ff;\n    box-shadow: 0 0 10px rgba(119, 182, 255, .7);\n  }\n\n  &.loading {\n    opacity: 1;\n    transition: none;\n\n    .progress {\n      transition: width .4s ease;\n    }\n  }\n}\n```\n\nJavaScript:\n\n```js\nvar loadingBar = document.querySelector(\".loading-bar\");\nvar progress = document.querySelector(\".loading-bar .progress\");\nvar timer = null;\n\n// Pjax 开始时执行的函数\ndocument.addEventListener(\"pjax:send\", function () {\n  // 进度条默认已经加载 20%\n  var loadingBarWidth = 20;\n  // 进度条的最大增加宽度\n  var MAX_LOADING_WIDTH = 95;\n\n  // 显示进度条\n  loadingBar.classList.add(\"loading\");\n  // 初始化进度条的宽度\n  progress.style.width = loadingBarWidth + \"%\";\n\n  clearInterval(timer);\n  timer = setInterval(function () {\n    // 进度条的增加速度（可以改为一个随机值，显得更加真实）\n    loadingBarWidth += 3;\n\n    // 当进度条到达 95% 后停止增加\n    if (loadingBarWidth > MAX_LOADING_WIDTH) {\n      loadingBarWidth = MAX_LOADING_WIDTH;\n    }\n\n    progress.style.width = loadingBarWidth + \"%\";\n  }, 500);\n});\n\n// Pjax 完成之后执行的函数\ndocument.addEventListener(\"pjax:complete\", function () {\n  clearInterval(timer);\n  progress.style.width = \"100%\";\n  loadingBar.classList.remove(\"loading\");\n\n  setTimeout(function () {\n    progress.style.width = 0;\n  }, 400);\n});\n```\n\n上面的代码基本上实现了 Github 中 Pjax 加载进度条的效果，仅供参考。具体效果可以在我的[个人博客](https://liuyib.github.io/)上体验一下。\n\n### 重载 JS 脚本\n\n**这里的重载指的是重新加载**。由于通过 Pjax 切换的页面并没有完全刷新，浏览器不会将网页从头执行一遍，因此有些 JS 将不会生效。重载 JS 脚本大致分为三种：一种是重载 JS 函数，一种是重载整个 JS 文件，另一种是重载内联的 `script` 标签。\n\n1）重载 JS 函数\n\n这种重载一般适用于用户自己编写的一些 JS 函数。但是具体情况比较复杂，函数要不要重载还得具体分析。下面举一些例子：\n\n- 页面不变部分对应的事件\n\n  比如，页面顶部栏有一个搜索按钮，点击之后会弹出搜索框：\n\n  ```js\n  document.querySelector(\".search-button\").onclick = function () {\n    // ...\n  };\n  ```\n\n  由于页面顶部栏不变，所以其中的元素上绑定的事件仍然可以使用，这部分元素对应的 JS 事件不需要重载。\n\n- 页面可变部分对应的事件\n\n  比如，页面主体部分是变化的，懒加载其中的图片：\n\n  ```js\n  var imgs = document.querySelectorAll(\"#main img.lazyload\");\n\n  lazyload(imgs);\n  ```\n\n  当通过 Pjax 切换页面后，由于主体部分改变，上述代码已经失效，因此需要进行重载。为了方便使用，我们使用函数封装一下：\n\n  ```js\n  function pjax_reload() {\n    var imgs = document.querySelectorAll(\"#main img.lazyload\");\n\n    lazyload(imgs);\n  }\n\n  // Pjax 完成后，重新加载上面的函数\n  document.addEventListener(\"pjax:complete\", function () {\n    pjax_reload();\n  });\n  ```\n\n2）重载整个 JS 文件\n\n这种情况多数用于第三方文件，比如，卜算子统计的脚本、谷歌/百度/腾讯分析的脚本等，这些脚本在每一次页面加载后都需要执行。\n\n我的做法是，在引入这些文件的标签上添加 `data-pjax` 属性，然后将具有这个属性的标签重新添加在页面中。有时候不方便在这些标签上添加额外的属性，那么你可以在这些标签外套一层标签，如 `<div class=\".pjax-reload\"></div>`，然后将 `.pjax-reload` 里的元素全部重新添加到页面中即可。代码示例如下：\n\n```html\n<script\n  data-pjax\n  src=\"https://cdn.jsdelivr.net/gh/sukkaw/busuanzi/bsz.pure.mini.js\"\n></script>\n\n<div class=\".pjax-reload\">\n  <script src=\"https://www.google-analytics.com/analytics.js\"></script>\n</div>\n```\n\n```js\n// jQuery 写法\n$(\"script[data-pjax], .pjax-reload script\").each(function () {\n  $(this).parent().append($(this).remove());\n});\n\n// JS 写法\ndocument\n  .querySelector(\"script[data-pjax], .pjax-reload script\")\n  .forEach(function (elem) {\n    var id = element.id || \"\";\n    var src = element.src || \"\";\n    var code = element.text || element.textContent || element.innerHTML || \"\";\n    var parent = element.parentNode;\n    var script = document.createElement(\"script\");\n\n    parent.removeChild(element);\n\n    if (id !== \"\") {\n      script.id = element.id;\n    }\n\n    if (src !== \"\") {\n      script.src = src;\n      script.async = false;\n    }\n\n    if (code !== \"\") {\n      script.appendChild(document.createTextNode(code));\n    }\n\n    parent.appendChild(script);\n  });\n```\n\n看到两种写法的差距，感觉整个人都不好了。\n\n3）重载整个 `script` 标签\n\n这种情况和前面类似，如果一些 JS 脚本写在 `script` 标签中，并且需要重载，可以选择直接重载整个 `script` 标签。具体做法和上一步相同，在标签上添加 `data-pjax` 属性，然后将具有这个属性的标签重新添加到页面中。\n\n## 总结\n\n本文主要介绍了 Pjax 的基本用法，和一些常见问题的解决方法。下面，赶快动起手来，让你的网站使用 Pjax 吧。\n\n---\n\n参考资料：\n\n- [pjax 是如何工作的？](https://www.zhihu.com/question/20289254)\n- [让你的网站实现 PJAX 无刷新](https://paugram.com/coding/add-pjax-to-your-website.html)\n","tags":["Pjax","第三方库","局部刷新"],"categories":["优化用户体验"]},{"title":"从 0 到 1 开发 Hexo 主题杂谈","url":"/2019/08/20/develop-hexo-theme-from-0-to-1/","content":"\n在没有开发自己的 Hexo 主题之前，我都是在 Github issues 里写[博客](https://github.com/liuyib/blog/issues)，但这样的做法总被小伙伴各种吐槽 (￣_￣ )。想到如果文章多的时候，使用 Github issues 浏览起来不够方便，所以还是换回了 Hexo。\n\n<!-- more -->\n\n使用 Hexo 首先是要挑选喜欢的主题，以我个人的感受来讲，Hexo 的主题虽然有两百多个，但是能拿出手的也就不到二十个。其中我最佩服的主题 Next 已经足够优秀，但是风格我并不喜欢，最后决定自己开坑。\n\n本文主要记录了我从零开发 Hexo 主题 -- [Stun](https://github.com/liuyib/hexo-theme-stun) 时，遇到的所有坑和经验，**仅供参考**，有不足的地方欢迎指出。\n\n## 知识储备\n\n### 模板引擎\n\n传统的 HTML 写起来既不方便，又不能复用，因此在 Hexo 中通常使用模板引擎来呈现网站内容。\n\n常用的几种模板引擎有：[Swig](https://github.com/paularmstrong/swig)、[EJS](https://github.com/hexojs/hexo-renderer-ejs)、[Haml](https://github.com/hexojs/hexo-renderer-haml) 或 [Jade](https://github.com/hexojs/hexo-renderer-jade)。其中 Jade 由于商标问题，改名为 [Pug](https://github.com/pugjs/pug)，虽然它们是兼容的，但使用的时候，推荐安装 Pug 而不是 Jade。Hexo 内置了 Swig，将文件扩展名改为 `.swig` 即可使用，你也可以安装插件来获得另外几种模板引擎的支持，Hexo 会根据文件扩展名来决定使用哪一种。例如：\n\n``` text\nlayout.pug   -- 使用 pug\nlayout.swig  -- 使用 swig\n```\n\n这里你需要做的是，选择一个自己喜欢的模板引擎，然后浏览文档，了解这个模板引擎的基本用法。\n\n- 英文文档地址分别如下：[Swig](https://node-swig.github.io/swig-templates/docs/)、[EJS](https://ejs.co/#docs)、[Pug](https://pugjs.org/api/getting-started.html)、[Haml](http://haml.info/docs.html)。\n- 中文文档地址分别如下：[Swig](https://myvin.github.io/swig.zh-CN/docs/index.html)、[EJS](https://ejs.bootcss.com/#docs)、[Pug](https://pugjs.org/zh-cn/api/getting-started.html)、Haml（无）。\n\n这里我选择了 Pug，不过我还是推荐使用 Swig 或 EJS。\n\n### CSS 预处理语言\n\n你可以使用原生 CSS 来写样式，但是原生 CSS 难以复用，不能使用循环，不能使用布尔判断，书写不够方便，等等。这会导致主题开发变得相对麻烦，甚至某些功能无法实现，因此最好是使用 CSS 预处理语言。\n\n常见的 CSS 预处理语言有：[Less](http://lesscss.org/)、[Sass](https://sass-lang.com/)、[Stylus](http://stylus-lang.com/)。至于它们的选择，根据自己的喜好即可。Hexo 默认使用的是 Stylus，它的功能足够强大，完全够用，因此我选用了 Stylus。\n\n### Hexo 相关知识\n\n有关 Hexo 的知识，这里只列举必要的部分。\n\n#### 构建 Hexo 开发环境\n\n开发主题之前，你需要搭建 Hexo 工作目录，有两种方式可供选择：\n\n1. 使用 `hexo-cli`\n2. 克隆 Hexo 主题的单元测试项目\n\n第一种方式，去 Hexo [官网](https://hexo.io/zh-cn/)，按照提示安装 `hexo-cli` 并生成你的 Hexo 工作目录，目录主要部分如下：\n\n``` text\n.\n├── scaffolds\n├── source\n|   └── _posts\n├── themes\n├── .gitignore\n├── _config.yml\n└── package.json\n```\n\n第二种方式，克隆 Hexo 官方的[单元测试库](https://github.com/hexojs/hexo-theme-unit-test)，这样会得到同上的文件目录。然后执行指令 `npm install` 安装所有依赖。\n\n对于一般的 Hexo 用户，基本都是使用第一种方式。不过对于 Hexo 主题开发者来说，如果你的主题将来要发布到 Hexo 的[主题列表](https://hexo.io/themes)，建议直接在 Hexo 的主题单元测试项目中进行开发，也就是第二种方式。因为 Hexo 建议在主题发布前，对主题进行单元测试，确保每一项功能都能正常使用。Hexo 提供的单元测试库包括了所有的边缘情况，例如：文章标题过长时的显示效果、文章标题为空时的显示效果（是什么都不显示，还是显示一些默认的提示文字）、对 Front-Matter 的支持程度，等等。直接使用 Hexo 主题的单元测试项目作为你的开发目录，就可以在开发过程中注意到这些边缘情况，而不是开发完再去测试。\n\n搭建完 Hexo 开发环境后，需要安装相关插件来支持你所使用的渲染引擎。Hexo 默认安装的渲染引擎是 EJS 和 Stylus，并且 Hexo 内置了 Swig，因此，如果你选用了 `EJS + Stylus` 或 `Swig + Stylus`，那么可以忽略这段，如果你选择了其他的渲染引擎，需要自行选择安装：\n\n``` bash\n# Templates\n$ npm install --save hexo-renderer-ejs\n$ npm install --save hexo-renderer-pug\n$ npm install --save hexo-renderer-haml\n\n# Styles\n$ npm install --save hexo-renderer-less\n$ npm install --save hexo-renderer-sass\n$ npm install --save hexo-renderer-stylus\n```\n\n#### 生成主题结构目录\n\n上一步只是搭建好了 Hexo 工作目录，接下来是创建主题的文件目录，你可以参考着已有的主题的文件目录手动创建，也可以使用 `Yeoman` 自动生成，使用 `Yeoman` 自动生成的步骤如下。\n\n1. 安装\n\n``` bash\n$ npm install --global yo\n$ npm install --global generator-hexo-theme\n```\n\n2. 生成\n\n进入 Hexo 的 `themes` 目录中，新建一个文件夹作为你的主题目录，然后进入该文件夹中，执行指令：\n\n``` bash\nyo hexo-theme\n```\n\n按照提示，填写或选择相应的信息，如下图：\n\n![](/assets/posts/develop-hexo-theme-from-0-to-1/init-hexo-by-yeoman.png)\n\n生成的文件目录如下：\n\n``` text\n.\n├── layout        # 布局文件夹\n|   ├── includes\n|   |   ├── layout.pug       # 页面总体布局\n|   |   └── recent-posts.pug # 文章列表\n|   ├── index.pug            # 首页\n|   ├── archive.pug          # 归档页\n|   ├── category.pug         # 分类页\n|   ├── tag.pug              # 标签页\n|   ├── post.pug             # 文章页\n|   └── page.pug             # 除以上页面之外的页面\n├── scripts       # 脚本文件夹\n├── source        # 资源文件夹\n|   ├── css\n|   ├── js\n|   └── favicon.ico\n├── .editorconfig # 编辑器配置文件\n├── _config.yml   # 主题配置文件\n└── package.json\n```\n\n当然只有这些文件目录是不够的，我们还需要另外添加一些其他的文件或目录，例如，`languages` 目录，放置语言文件，用于[国际化（i18n）](https://hexo.io/zh-cn/docs/internationalization)设置（如果你的主题需要支持多语言，就添加该目录，否则不用添加）。\n\n有关以上目录的介绍，详参见：[Hexo 主题](https://hexo.io/zh-cn/docs/themes)。\n\n> 这里需要提一下，主题目录和 Hexo 根目录中各有一个 `source` 文件夹，当你执行指令 `hexo generate` 来生成静态文件时，这两个 `source` 目录中的文件如果是 Markdown 文件，则会被解析为 HTML，而其他类型的文件则会被复制到 `public` 目录中。`public` 目录用于存放打包后生成的文件，这些文件就是线上跑的网站资源文件。**因此，如果你不清楚 `source` 目录里文件的使用路径是怎样的，那么你可以跑一下指令 `hexo generate`，这些文件生成到 `public` 目录中后，它们的路径关系就很明显了。**\n\n#### 通读文档\n\n虽然 Hexo 的文档确实很差劲，文档下面的评论区全是吐槽，而且有些部分中英文版本没有同步，但是如果能耐心读完，会有很大的收益，我个人的最大感受是 Hexo 的文档真的特别重要。当然一次掌握是不可能的，我的建议是在开发时每隔一段时间过一遍（Hexo 的一些重要功能，例如：标签插件、Front-Matter，等等，也只有通过阅读文档熟悉了之后，才能更好的实现和支持）。\n\n刚开始开发主题，不可能理解 Hexo 文档中提到的所有地方，但是有两个点必须首先掌握：[变量](https://hexo.io/zh-cn/docs/variables)和[辅助函数](https://hexo.io/zh-cn/docs/helpers)，这两点在开发时会经常用到，并且贯穿整个开发过程。\n\n## 主题开发\n\n有了上述的准备后，就可以开始主题的开发了。下面是主题开发中一些值得注意的地方，了解这些，可以帮助你避免踩重复的坑。\n\n### 主题配置文件\n\n主题的配置文件采用了 [Yaml](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html) 语法，和 Json 类似，了解一下语法格式就可以上手使用了。\n\n开发主题时，有的功能可以让用户自己配置，因此我们需要将这些功能的配置项暴露出来，填充到主题的配置文件 `_config.yml` 中。然后在模板引擎中，你可以通过 Hexo 内置的 `theme` 变量来获取这些配置项。例如：\n\n配置文件：\n\n``` yaml _config.yml\ncopyright:\n  enable: true\n  text:\n```\n\n这样使用：\n\n``` html\n// -------------------- Pug 语法 --------------------\nif theme.copyright.enable\n  div.copyright= theme.copyright.text\n\n// -------------------- Swig 语法 --------------------\n{% if theme.copyright.enable %}\n<div class=\"copyright\">{{ theme.copyright.text }}</div>\n{% endif %}\n```\n\n{% note default %}\n文章接下来的部分中，模板语言示例代码都会用 Pug 和 Swig 两种语法给出。\n{% endnote %}\n\n随着项目的发展，配置文件会越来越大，上面这种做法的缺点也会越来越明显。\n\n- 对于使用者\n\n  当更新主题时，由于配置文件会被覆盖，因此用户必须提前将配置文件备份，等更新完主题后再将备份的数据拷贝回去，这个过程繁琐又容易出错。\n\n- 对于开发者\n\n  在发布主题时，开发者不可能将自己测试用的数据保留在主题配置文件中，而应该预留一份干净的配置文件。因此每次发布主题之前，都需要把主题配置文件里的测试数据清空、备份，然后等发布完主题后再恢复回来。这种做法是无法令人忍受的，因为每次 `git commit` 之前都需要这样做一次。\n\n因此我们需要一种更友好的方式来使用配置文件。在查找资料和参考现有主题 NexT、Melody 的实现后，发现可以利用 Hexo 3.0 提供的新特性 -- [数据文件](https://hexo.io/zh-cn/docs/data-files)，来解决上面的痛点。\n\n使用方法如下，在 Hexo 根目录下的 `source/_data` 文件夹中（没有的文件夹需要自己创建），新建一个 Yaml 配置文件，并**命名为主题的名称**，例如 Stun 主题，就叫做 `stun.yml`。然后将主题配置文件 `_config.yml` 里的内容复制到 `stun.yml` 中，这样 `stun.yml` 就会覆盖 `_config.yml`。如果想要修改配置，直接修改 `stun.yml` 就好了。当用户更新主题或者开发者发布主题时，配置数据保存在 `stun.yml` 中，主题原来的配置文件 `_config.yml` 仍然是干净的。\n\n下面是代码实现，在主题根目录下的 `scripts` 文件夹中（没有就新建），添加一个 JS 文件，文件名随意，添加如下代码：\n\n``` js\nhexo.on('generateBefore', function () {\n  var rootConfig = hexo.config;\n\n  if (hexo.locals.get) {\n    // 获取 source/_data 目录下的文件\n    var data = hexo.locals.get('data');\n\n    // 如果存在 stun.yml 文件，就用它覆盖原来的配置文件\n    if (data && data.stun) {\n      hexo.theme.config = data.stun;\n    }\n  }\n\n  hexo.theme.config.rootConfig = rootConfig;\n});\n```\n\n### 页面搭建\n\n你需要分析主题页面的结构，将能够公用的部分抽离出来，例如：\n\n- HTML 的 `head` 部分\n- 顶部导航栏\n- 页面头部、底部\n- 页面侧边栏\n- 页面主体部分（显示文章的地方）\n- ......\n\n将这些部分对应的代码放在主题 `layout` 目录下的 `layout.pug` 文件中用以复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n  body\n    header#header.header\n      div.header-inner\n        include ./header.pug\n    \n    main#main.main\n      div.main-inner\n        div#content.content\n          div.content-inner\n            block content\n        \n        div#sidebar.sidebar\n          div.sidebar-inner\n            block sidebar\n\n    footer#footer.footer\n      div.footer-inner\n        include ./footer.pug\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n\n  <body>\n    <header id=\"header\" class=\"header\">\n      <div class=\"header-inner\">\n        {% include './header.swig' %}\n      </div>\n    </header>\n\n    <main id=\"main\" class=\"main\">\n      <div class=\"main-inner\">\n        <div id=\"content\" class=\"content\">\n          <div class=\"content-inner\">\n            {% block content %}{% endblock %}\n          </div>\n        </div>\n        \n        <div id=\"sidebar\" class=\"sidebar\">\n          <div class=\"sidebar-inner\">\n            {% block sidebar %}{% endblock %}\n          </div>\n        </div>\n      </div>\n    </main>\n\n    <footer id=\"footer\" class=\"footer\">\n      <div class=\"footer-inner\">\n        {% include './footer.swig' %}\n      </div>\n    </footer>\n  </body>\n</html>\n```\n\n`layout.pug` 是网站最基础的布局代码，所有的页面都是继承它而来。Pug / Swig 使用 `extends` 和 `block` 实现继承，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\nhtml\n  head\n    title\n      block title\n\n  body\n    block content\n\n// -------------------- Swig 语法 --------------------\n<html>\n  <head>\n    <title>{% block title %}{% endblock %}</title>\n  </head>\n  <body>\n    {% block content %}{% endblock %}\n  </body>\n</html>\n```\n\n``` html\n// -------------------- Pug 语法 --------------------\nextends layout.pug\n\nblock title\n  My Page\n\nblock content\n  This is a awesome page.\n\n// -------------------- Swig 语法 --------------------\n{% extends 'layout.swig' %}\n\n{% block title %}My Page{% endblock %}\n\n{% block content %}\n<p>This is a awesome page.</p>\n{% endblock %}\n```\n\n除了继承的方式复用代码，还可以通过 `include` 语法直接引文件来实现代码复用，例如：\n\n``` html\n// -------------------- Pug 语法 --------------------\ndiv#header.header\n  include ./header.pug\n\n// -------------------- Swig 语法 --------------------\n<div id=\"header\" class=\"header\">\n  {% include './header.swig' %}\n</div>\n```\n\n> 由于 `layout.pug` 只用于被其他页面继承，并不会单独渲染成页面，因此，可以将文件名改为 `_layout.pug`（以下划线开头）这样 Hexo 就不会解析这个文件，可以提高 Hexo 生成页面的速度。\n\n这里我并不准备介绍页面中更详细的部分如何实现，直接看[源码](https://github.com/liuyib/hexo-theme-stun)效果更好。\n\n### 数据交互\n\n这里介绍下 Pug / Swig、Stylus、JavaScript 这几种文件如何与主题配置文件进行数据交互。\n\n前面我们已经知道了，主题配置文件里的配置项被包含在 `theme` 变量下。因此在我们需要知道如何在另外三种文件中使用 `theme` 变量：\n\n- 在 Pug / Swig 文件中使用\n\n  ``` html\n  // -------------------- Pug 语法 --------------------\n  div= theme.copyright.text\n\n  html(lang=theme.language)\n\n  if theme.sidebar.enable\n    div.sidebar\n\n  div(class=`sidebar ${ if theme.sidebar.show ? 'show' : '' }`)\n\n  // -------------------- Swig 语法 --------------------\n  <div>{{ theme.copyright.text }}</div>\n\n  <html lang=\"{{ theme.language }}\"></html>\n\n  {% if theme.sidebar.enable %}\n    <div class=\"sidebar\"></div>\n  {% endif %}\n\n  <div class=\"sidebar {% if theme.sidebar.show %}show{% endif %}\"></div>\n  ```\n\n- 在 Stylus 文件中使用\n\n  需要通过 Hexo 内置的函数 `hexo-config` 来获取 `theme` 变量中的属性，但是不需要加 `theme.` 前缀：\n\n  ``` stylus\n  // back2top 是 theme 变量下的一个属性\n  if (hexo-config('back2top.enable'))\n    .back2top\n      display: block\n\n  // 如果配置项的值中含有样式，需要使用 Stylus 的 convert 函数转换一下\n  .post-title\n    color: convert(hexo-config('post.title.color'))\n  ```\n\n  > 在其他的 CSS 预处理语言中，理论上也可以通过 `hexo-config` 来获取 `theme` 变量中的属性，我没试过，开发者可以自行尝试。\n\n- 在 JavaScript 文件中使用\n\n  在 JS 文件中没有办法直接获取到 Hexo 内置的 `theme` 变量，但是我们可以换一种方式来间接获取。新建一个模板引擎文件，我们就叫它 `config.pug`，文件内容如下所示：\n\n  ``` html\n  // ----- Pug 语法（注意 script 标签后面的点，表示该标签后面有多行代码）-----\n  script.\n    var CONFIG = {\n      sidebar: '!{ theme.sidebar }',\n      back2top: '!{ theme.back2top }',\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n\n  // -------------------- Swig 语法 --------------------\n  <script>\n    var CONFIG = {\n      sidebar: {{ theme.sidebar | json_encode }},\n      back2top: {{ theme.back2top | json_encode }},\n      ...\n    };\n\n    window.CONFIG = CONFIG;\n  </script>\n  ```\n\n  然后将 `config.pug` 文件放在 HTML 的 `head` 标签中加载，这样就可以通过全局变量 `CONFIG` 在 JS 中获取主题配置文件里的数据了。\n\n到这里为止，就介绍完了开发 Hexo 主题前必要的知识储备，剩下的就靠开发者自己完成了。\n\n## 发布主题\n\n发布主题之前你需要进行[主题单元测试](https://github.com/hexojs/hexo-theme-unit-test)，确保每一项功能都能正常使用。如果你是按照我之前介绍的方法，直接 Hexo 的主题单元测试库中开发主题，那么你应该就不需要进行这一步了。\n\n1、Fork [hexojs/site](https://github.com/hexojs/site)\n2、编辑 `source/_data/themes.yml`，在文件中新增您的主题：\n\n``` yaml themes.yml\n- name: Stun\n  description: A beautiful & simple theme\n  link: https://github.com/liuyib/hexo-theme-stun\n  preview: https://liuyib.github.io/\n  tags:\n    - responsive\n    - beautiful\n    - simple\n    - two_column\n```\n\n3、在 `source/themes/screenshots` 中添加一个和你主题同名的图片，图片必须为 800*500 的 PNG 文件。\n4、发起新的合并申请（pull request）。\n\n最后，只需要等待 Hexo 仓库的维护人员收录你的主题即可。\n\n---\n\n参考资料：\n\n- [Hexo主题开发经验杂谈](https://molunerfinn.com/make-a-hexo-theme/)\n- [Hexo 主题开发指南](http://chensd.com/2016-06/hexo-theme-guide.html)\n","tags":["Hexo"],"categories":["Hexo 主题开发"]},{"title":"theme-stun-gitter","url":"/2019/07/26/theme-stun-gitter/","content":"\nThis is a link for Gitter of theme-stun. Clicking on the title to talking.\n"},{"title":"前端单元测试和持续集成","url":"/2019/06/04/front-end-unit-test-and-ci/","content":"\n前端的单元测试包括但不限于：单元功能测试、UI 测试、兼容性测试等等。一个测试体系大体包括四部分：\n\n- 测试运行器（e.g. [Karma](https://github.com/karma-runner/karma)）\n- 测试框架（e.g. [Mocha](https://github.com/mochajs/mocha), [Jest](https://github.com/facebook/jest), [Jasmine](https://github.com/jasmine/jasmine), [Qunit](https://github.com/qunitjs/qunit)）\n- 断言库（e.g. [Should](https://github.com/shouldjs/should.js), [Chai](https://github.com/chaijs/chai)）\n- 测试覆盖率（e.g. [Istanbul](https://github.com/gotwarlost/istanbul)）\n\n<!-- more -->\n\n本文会通过一个例子，来一步步了解如何进行前端单元测试。\n\n> 本文举的例子中，没有涉及测试运行器，只涉及测试框架、断言库和测试覆盖率。并以 `Mocha + Should + Istanbul` 组合为例。\n>\n> 如果你知道 Karma 是干什么的，并且需要用到它，推荐阅读我的另一篇文章：[使用 Karma + Mocha 构建 Web 单元测试环境](https://liuyib.github.io/2020/03/20/use-karma-mocha-chai-to-test/)\n\n## 新建项目\n\n如果你的电脑上没有安装 Node.js，那么你需要访问它的[官网](https://nodejs.org/zh-cn/)，下载并安装到你的电脑上。NPM 是 Node.js 的包管理工具，会随着 Node.js 一起安装。\n\n然后，我们需要用 NPM（Node Package Manager）来管理依赖包，所以先初始化 NPM 的配置文件 `package.json`，执行指令：\n\n```bash\n$ npm init -y\n```\n\n> `-y` 参数表示不进行询问，直接使用默认的配置。\n\n下面我们在 `src` 目录下，新建 `main.js` 文件，并编写一个 `factorial` 函数（用于求数的阶乘）：\n\n```js\n// main.js\n\nvar factorial = function(n) {\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n\nif (require.main === module) {\n  // 如果是在命令行中执行 main.js，则此处会执行。\n  // 如果 main.js 被其他文件 require，则此处不会执行。\n  var n = Number(process.argv[2]);\n  console.log('factorial(' + n + ') is', factorial(n));\n}\n```\n\n运行一下这个文件，看看结果是否正确。执行指令：`node ./src/main.js 5`，效果如下：\n\n![](/assets/posts/front-end-unit-test-and-ci/run-main-file-in-node.png)\n\n结果是 `120`，符合预期。但是一个例子并不能说明什么，我们还需要对负数、非数字、小数、很大的数等进行验证，在逐步的验证过程中，代码中的不足也会逐渐暴露出来。所以接下来我们将进行**测试驱动开发**（Test-Driven Development, TDD），通过不断的测试来完善代码。\n\n## 编写测试文件\n\n首先，在 `main.js` 文件最后添加代码：\n\n```js\nexports.factorial = factorial;\n```\n\n这段代码的作用是将 `factorial` 函数暴露出去，这样才可以在其他文件中 `require` 这个函数。\n\n通常，测试文件与所要测试的源文件同名，但是后缀名为 `.test.js`（表示测试）或 `.spec.js`（表示规格）。例如，`main.js` 的测试文件就是 `main.test.js`：\n\n```js\n// main.test.js\n\nvar main = require('../src/main');\nvar should = require('should');\n\ndescribe('test/main.js', function() {\n  it('should equal 1 when n === 0', function() {\n    should(main.factorial(0)).equal(1);\n  });\n});\n```\n\n上面的代码中：\n\n- `describe` 块称为“测试套件（test suite）”，表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。\n\n- `it` 块称为“测试用例（test case）”，表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。\n\n一个测试文件中，可以包含一个或多个 `describe` 块，一个 `describe` 块中可以包含一个或多个 `it` 块。\n\n想要运行这个测试文件，需要安装依赖 Mocha 和 Should：\n\n```bash\n$ npm install --save-dev mocha should\n```\n\n然后，在 `package.json` 中新建一条 NPM 指令：\n\n```json\n...\n\"scripts\": {\n  \"test\": \"./node_modules/.bin/mocha ./test/main.test.js\"\n}\n...\n```\n\n该指令的作用就是：使用安装在项目目录中的 Mocha 命令 `./node_modules/.bin/mocha` 来测试 `./test/main.test.js` 文件。\n\n执行这个指令 `npm run test`，结果如下（可以看到测试通过）：\n\n![](/assets/posts/front-end-unit-test-and-ci/mocha-test-one-case.png)\n\n到这里，我们就使用测试框架 + 断言库，体验了基本的单元测试流程，接下来我们通过不断完善测试用例，来使代码健壮起来。\n\n## 完善测试用例\n\n首先，明确函数功能。我们的 `factorial` 函数应该有以下功能：\n\n- 当 `n === 0` 时，返回 `1`。\n- 当 `n > 0` 时，返回 `factorial(n - 1) * n`。\n- 当 `n < 0` 时，抛出错误，因为没有意义。\n- 当 `n` 不是数字时，抛出错误。\n- 当 `n > 10` 时，抛出错误（本文为了演示，只进行 `10` 以内的阶乘运算）。\n\n然后，我们根据确定好的功能来完善测试用例：\n\n```js\nvar main = require('../src/main');\nvar should = require('should');\n\ndescribe('test/main.js', function() {\n  it('should equal 1 when n === 0', function() {\n    should(main.factorial(0)).equal(1);\n  });\n\n  it('should equal 1 when n === 1', function() {\n    should(main.factorial(1)).equal(1);\n  });\n\n  it('should equal 3628800 when n === 10', function() {\n    should(main.factorial(10)).equal(3628800);\n  });\n\n  it('should throw when n > 10', function() {\n    (function() {\n      main.factorial(11);\n    }.should.throw('n should <= 10'));\n  });\n\n  it('should throw when n < 0', function() {\n    (function() {\n      main.factorial(-1);\n    }.should.throw('n should >= 0'));\n  });\n\n  it('should throw when n is not Number', function() {\n    (function() {\n      main.factorial('123');\n    }.should.throw('n should be a Number'));\n  });\n});\n```\n\n执行测试指令 `npm run test`，效果如下：\n\n![](/assets/posts/front-end-unit-test-and-ci/mocha-test-some-case-1.png)\n\n可以看到后面三个测试用例都没有通过，这说明 `factorial` 函数并不是在所有情况下都可以正常运行，所以我们需要更新 `factorial` 的实现：\n\n```js\nvar factorial = function(n) {\n  if (typeof n !== 'number') {\n    throw new Error('n should be a Number');\n  }\n\n  if (n < 0) {\n    throw new Error('n should >= 0');\n  }\n\n  if (n > 10) {\n    throw new Error('n should <= 10');\n  }\n\n  if (n === 0) {\n    return 1;\n  }\n\n  return factorial(n - 1) * n;\n};\n```\n\n再次执行测试指令 `npm run test`，效果如下：\n\n![](/assets/posts/front-end-unit-test-and-ci/mocha-test-some-case-2.png)\n\n可以看到，所有的测试用例都通过了，这证明 `factorial` 函数的功能已经符合了我们的预期要求，而且代码健壮性有了很大的提高。\n\n以上就是 TDD 的基本流程，总的来说就是：**首先明确程序的功能，然后跑测试用例，如果测试用例没有通过，修改程序，直到测试用例通过**。\n\n## 生成覆盖率\n\n如果你想知道测试用例是否合理，可以用“代码覆盖率”来判断。一般而言，如果测试用例写的合理，那么代码覆盖率越高越好，但不是绝对的。\n\n代码覆盖率包括以下几个方面：\n\n- **行覆盖率**：是否每一行都执行了\n- **函数覆盖率**：是否每个函数都调用了\n- **分支覆盖率**：是否每个 `if` 代码块都执行了\n- **语句覆盖率**：是否每个语句都执行了\n\n生成代码覆盖率，需要用到插件 Istanbul，首先将其安装：\n\n```bash\n$ npm install --save-dev istanbul\n```\n\n然后，在 `package.json` 中新建一条 NPM 指令，用于生成覆盖率：\n\n```json\n...\n\"scripts\": {\n  \"coverage\": \"./node_modules/.bin/istanbul cover ./node_modules/mocha/bin/_mocha\"\n}\n...\n```\n\n> 注意，指令中 `_mocha` 的下划线不能省略。因为，`mocha` 和 `_mocha` 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 Istanbul 所在的进程）执行测试，只有这样， Istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n执行这个指令 `npm run coverage`，结果如下：\n\n![](/assets/posts/front-end-unit-test-and-ci/code-coverage-in-cli-1.png)\n\n将 `coverage/lcov-report` 目录下的 `index.html` 文件在浏览器中运行，可以查看具体的覆盖率。如图所示：\n\n![](/assets/posts/front-end-unit-test-and-ci/code-coverage-in-browser.png)\n\n其实，这次的覆盖率应该是 100%，因为函数在被其他文件引用时 24、25 这两行不会执行，所以没法测。由于这两行代码仅仅是为了刚开始方便演示用，之后我们就不在命令行中测试了，所以直接将这两行语句所在的 `if` 块删除即可。\n\n再次执行测试指令，就得到了 100% 的覆盖率：\n\n![](/assets/posts/front-end-unit-test-and-ci/code-coverage-in-cli-2.png)\n\n## 上传覆盖率\n\n想要展示测试覆盖率，有两个网站可供选择：[Codecov](https://codecov.io/) 和 [Coveralls](https://coveralls.io/)。本文以 Codecov 为例。\n\n首先，打开 Codecov 官网，绑定 Github 账号之后，选择要展示测试覆盖率的仓库。\n\n然后，安装 Codecov：\n\n```bash\n$ npm install --save-dev codecov\n```\n\n接着，在 `package.json` 中新建一条 NPM 指令，来上传测试覆盖率：\n\n```json\n...\n\"script\": {\n  \"codecov\": \"cat ./coverage/lcov.info | ./node_modules/.bin/codecov\"\n}\n...\n```\n\n> 其中 `cat ./coverage/lcov.info` 用于读取 `coverage` 目录下的 `lcov.info` 文件，`./node_modules/.bin/codecov` 用于将覆盖率上传到 Codecov 网站。\n\n该指令在接下来配置 CI（Continuous integration, 持续集成）时会用到。\n\n## 持续集成\n\n如果每次修改代码之后，都手动进行单元测试，不仅加重工作量，而且容易出错，因此我们需要进行自动化测试，这就用到了持续集成。\n\n持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，测试等）来验证，从而尽早地发现代码中的错误。\n\n可供选择的持续集成工具有 [Travis CI](https://travis-ci.org/) 和 [Circle CI](https://circleci.com/)。本文以 Travis CI 为例。\n\n### 使用 Travis CI\n\n首先，Travis CI 进入官网后，点击 Sign In 按钮绑定 Github。然后在仓库列表中选择你要进行持续集成的仓库，点击按钮启用：\n\n![](/assets/posts/front-end-unit-test-and-ci/travis-ci-settings.png)\n\n然后，你需要在项目根目录下创建 `.travis.yml` 文件（如果没有这个文件，Travis CI 会默认执行 `npm install` 和 `npm test`），配置文件示例如下：\n\n```yml\n# 要使用的语言\nlanguage: node_js\n\n# 要使用的语言版本\nnode_js:\n  - 10\n\n# 缓存 NPM 依赖，加快构建\ncache:\n  directories:\n    - node_modules\n\n# 安装依赖\ninstall:\n  - npm install\n\n# 执行指令\nscript:\n  - npm run coverage\n\n# 指令执行成功后\nafter_success:\n  - npm run codecov\n\n# 指定分支\nbranches:\n  only:\n    - master\n```\n\n最后，将所有修改提交到远程仓库的 master 分支上，就可以看到 Travis CI 正在自动构建。\n\n### 展示徽章\n\n当 CI 构建完成之后，我们可以通过访问 Travis CI 和 Codecov 的网站查看到详细结果，当然也可以将结果以徽章的形式放入 README，这样更清晰明了。\n\nTravis CI 的徽章这样获取：\n\n![](/assets/posts/front-end-unit-test-and-ci/travis-badge.png)\n\nCodecov 的徽章这样获取：\n\n![](/assets/posts/front-end-unit-test-and-ci/codecov-badge.png)\n\n每当 CI 构建完成，结果就会以徽章的形式，展示在你的项目文档中。\n\n---\n\n参考资料：\n\n- [《Node.js 包教不包会》测试用例：mocha，should，istanbul](https://github.com/alsotang/node-lessons/tree/master/lesson6)\n","tags":["单元测试","持续集成","Github 徽章"],"categories":["前端自动化"]}]